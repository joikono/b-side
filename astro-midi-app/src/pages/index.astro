---
// index.astro - Frontend-Only MIDI Analysis Demo with Integrated Player
// Perfect audio quality with Web MIDI API + Web Audio API + MIDI Playback
const apiBase = "http://localhost:8000";
import "../styles/global.css";
import CircularWaveform from "../components/circular_waveform.astro";
---

<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- Load the proven html-midi-player library -->
        <script
            src="https://cdn.jsdelivr.net/combine/npm/tone@14.7.58,npm/@magenta/music@1.23.1/es6/core.js,npm/focus-visible@5,npm/html-midi-player@1.4.0"
        ></script>
        <script src="https://cdn.skypack.dev/@tonejs/midi"></script>
    </head>
    <body>
        <!-- Full-Screen Waveform Centerpiece -->
        <div class="waveform-centerpiece">
            <div id="progressions" class="progression-overlay"></div>
            <CircularWaveform
                width="100vw"
                height="100vh"
                radius="40"
                maxBarHeight="30"
                barCount="128"
                showControls={false}
                className="spectrum-canvas"
            />
        </div>

        <!-- Overlay Controls (Minimal) -->
        <div class="overlay-controls">
            <!-- Visualizer status in corner -->
            <div class="corner-status" id="visualizerStatus">
                <span class="status-dot" id="audioStatusDot"></span>
                <span id="audioStatusText">Ready</span>
            </div>
        </div>

        <!-- Sticky MIDI Control Bar -->
        <div class="midi-control-bar">
            <div class="midi-bar-content">
                <!-- LEFT SECTION: Arrangement Controls -->
                <div class="left-controls">
                    <!-- Combined Track Player with Working Toggles -->
                    <div
                        id="combinedTrackPlayer"
                        class="combined-track-player"
                        style="display: none;"
                    >
                        <div class="combined-label">üéº Combined Playback</div>
                        <div class="combined-track-controls">
                            <midi-player
                                id="combinedTrackMidiPlayer"
                                src=""
                                sound-font="https://storage.googleapis.com/magentadata/js/soundfonts/sgm_plus"
                                loop
                            >
                            </midi-player>
                            <div class="mini-midi-controls">
                                <button
                                    onclick="playCombinedTrack()"
                                    class="mini-midi-btn">‚ñ∂Ô∏è</button
                                >
                                <button
                                    onclick="stopCombinedTrack()"
                                    class="mini-midi-btn">‚èπÔ∏è</button
                                >
                                <button
                                    onclick="toggleCombinedTrackLoop()"
                                    class="mini-midi-btn">üîÑ</button
                                >
                                <button
                                    onclick="saveCombinedTrack()"
                                    class="mini-midi-btn">üíæ</button
                                >
                            </div>
                        </div>
                        <!-- Track Toggle Controls -->
                        <div class="track-toggles">
                            <label class="track-toggle">
                                <input
                                    type="checkbox"
                                    id="userTrackToggle"
                                    onchange="toggleUserTrack(this.checked)"
                                />
                                <span>üéπ Your Recording</span>
                            </label>
                            <label class="track-toggle">
                                <input
                                    type="checkbox"
                                    id="arrangementTrackToggle"
                                    checked
                                    onchange="toggleArrangementTrack(this.checked)"
                                />
                                <span>üéµ Arrangement</span>
                            </label>
                        </div>
                    </div>

                    <!-- Arrangement controls in horizontal wrapper -->
                    <div class="arrangement-controls-container">
                        <button
                            class="arrangement-controls-toggle"
                            onclick="toggleArrangementControls()"
                            title="Arrangement Settings"
                        >
                            üéº
                        </button>
                        <!-- Expandable Arrangement Menu -->
                        <div
                            id="arrangementControlsMenu"
                            class="arrangement-controls-menu"
                        >
                            <div class="control-group">
                                <label>Style:</label>
                                <select id="stickyHarmonyStyle">
                                    <option value="simple_pop"
                                        >Simple/Pop</option
                                    >
                                    <option value="folk_acoustic"
                                        >Folk/Acoustic</option
                                    >
                                    <option value="bass_foundation"
                                        >Bass Foundation</option
                                    >
                                    <option value="phrase_foundation"
                                        >Phrase Foundation</option
                                    >
                                </select>
                            </div>
                            <div class="control-group">
                                <label>Bass:</label>
                                <input
                                    type="range"
                                    id="stickyBassComplexity"
                                    min="1"
                                    max="3"
                                    value="1"
                                />
                                <span id="stickyBassValue">1</span>
                            </div>
                            <div class="control-group">
                                <label>Drums:</label>
                                <input
                                    type="range"
                                    id="stickyDrumComplexity"
                                    min="1"
                                    max="3"
                                    value="1"
                                />
                                <span id="stickyDrumValue">1</span>
                            </div>
                        </div>
                    </div>

                    <!-- Generate Arrangement Button -->
                    <button
                        id="stickyGenerateBtn"
                        class="generate-arrangement-btn"
                        onclick="analyzeAndGenerate()"
                        title="Generate Full Arrangement"
                    >
                        üéµ Generate
                    </button>
                </div>

                <!-- CENTER SECTION: Piano Controls -->
                <div class="center-controls">
                    <div class="piano-controls-container">
                        <button
                            class="piano-controls-toggle"
                            onclick="togglePianoControls()"
                            title="Piano Settings"
                        >
                            üéπ
                        </button>
                        <!-- Expandable Piano Menu -->
                        <div id="pianoControlsMenu" class="piano-controls-menu">
                            <div class="midi-device-section">
                                <select
                                    id="deviceSelect"
                                    class="midi-dropdown"
                                    onchange="autoConnect()"
                                >
                                    <option value=""
                                        >Select MIDI Device...</option
                                    >
                                </select>
                                <button
                                    class="refresh-btn"
                                    onclick="loadDevices()"
                                    title="Refresh Devices"
                                >
                                    üîÑ
                                </button>
                            </div>
                            <div class="control-group">
                                <label>Volume:</label>
                                <input
                                    type="range"
                                    id="pianoVolume"
                                    min="0"
                                    max="100"
                                    value="10"
                                    oninput="updateMidiBarVolume(this.value)"
                                />
                                <span id="volumeValue">10%</span>
                            </div>
                            <div class="control-group">
                                <label>Sound:</label>
                                <select
                                    id="pianoSound"
                                    onchange="updateMidiBarSound(this.value)"
                                >
                                    <option value="piano">Piano</option>
                                    <option value="electric">Electric</option>
                                    <option value="organ">Organ</option>
                                    <option value="synth">Synth</option>
                                </select>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- RIGHT SECTION: Record & Metronome -->
                <div class="right-controls">
                    <div class="button-group">
                        <button
                            id="recordToggleBtn"
                            class="record-btn"
                            onclick="toggleRecording()"
                        >
                            üéôÔ∏è
                        </button>
                    </div>
                    <div id="beatIndicator" class="beat-indicator">
                        <div class="beat-circle" id="beatCircle"></div>
                        <div class="beat-count" id="beatCount"></div>
                    </div>
                </div>
            </div>
        </div>
    </body>
</html>

<script>
    // @ts-nocheck

    import { MidiRecorder } from "../lib/MidiRecorder.js";
    import { PianoSynth } from "../lib/PianoSynth.js";
    import { Metronome } from "../lib/Metronome.js";
    import { PrecisionMIDIPlayer } from "../lib/PrecisionMIDIPlayer.js";
    import { VoiceCommands } from "../lib/VoiceCommands.js";

    // API Configuration
    const API_BASE = "http://localhost:8000";

    // Global variables
    let metronome;
    let pianoSynth;
    let midiAccess;
    let midiInput;
    let midiRecorder;
    let spectrumInstance = null;
    let isPianoMenuOpen = false;
    let recordedTrackBlob = null;
    let recordedTrackUrl = null;
    let loopedTrackBlob = null;
    let loopedTrackUrl = null;
    let isArrangementMenuOpen = false;
    let voiceCommands = null;

    async function create8LoopMidi(originalMidiBlob) {
        try {
            console.log("üîÑ Creating 8-loop version...");

            const { Midi } = await import(
                "https://cdn.skypack.dev/@tonejs/midi"
            );
            const arrayBuffer = await originalMidiBlob.arrayBuffer();
            const originalMidi = new Midi(arrayBuffer);

            // Create new MIDI with proper constructor options
            const loopedMidi = new Midi();

            // Copy tempo events (this works)
            if (
                originalMidi.header.tempos &&
                originalMidi.header.tempos.length > 0
            ) {
                originalMidi.header.tempos.forEach((tempo) => {
                    loopedMidi.header.setTempo(tempo.bpm, tempo.time);
                });
            } else {
                // Ensure 100 BPM if no tempo found
                loopedMidi.header.setTempo(100, 0);
            }

            const singleLoopDuration = 9.6;
            const totalLoops = 8;

            console.log(
                `üîÑ Creating ${totalLoops} loops from ${originalMidi.tracks.length} tracks`,
            );

            originalMidi.tracks.forEach((originalTrack, trackIndex) => {
                const loopedTrack = loopedMidi.addTrack();

                // Copy track properties that are settable
                if (originalTrack.name)
                    loopedTrack.name = originalTrack.name + " (8x Loop)";
                if (originalTrack.channel !== undefined)
                    loopedTrack.channel = originalTrack.channel;

                let totalNotesAdded = 0;

                for (let loop = 0; loop < totalLoops; loop++) {
                    const loopStartTime = loop * singleLoopDuration;

                    // Add notes for this loop
                    originalTrack.notes.forEach((note) => {
                        if (note.time < singleLoopDuration) {
                            loopedTrack.addNote({
                                midi: note.midi,
                                time: note.time + loopStartTime,
                                duration: Math.min(
                                    note.duration,
                                    singleLoopDuration - note.time,
                                ),
                                velocity: note.velocity,
                            });
                            totalNotesAdded++;
                        }
                    });

                    // Add control changes for this loop
                    if (originalTrack.controlChanges) {
                        Object.keys(originalTrack.controlChanges).forEach(
                            (ccNumber) => {
                                const ccArray =
                                    originalTrack.controlChanges[ccNumber];
                                ccArray.forEach((cc) => {
                                    if (cc.time < singleLoopDuration) {
                                        loopedTrack.addCC({
                                            number: parseInt(ccNumber),
                                            value: cc.value,
                                            time: cc.time + loopStartTime,
                                        });
                                    }
                                });
                            },
                        );
                    }
                }

                console.log(
                    `üîÑ Track ${trackIndex}: ${originalTrack.notes.length} ‚Üí ${totalNotesAdded} notes (${totalLoops}x)`,
                );
            });

            // Convert to blob
            const loopedMidiArray = loopedMidi.toArray();
            const loopedMidiBlob = new Blob([loopedMidiArray], {
                type: "audio/midi",
            });

            const totalDuration = singleLoopDuration * totalLoops;
            console.log(
                `‚úÖ 8-loop MIDI created: ${loopedMidiBlob.size} bytes, ${totalDuration}s duration`,
            );

            return loopedMidiBlob;
        } catch (error) {
            console.error("‚ùå Failed to create 8-loop MIDI:", error);
            return null;
        }
    }

    function autoConnect() {
        const deviceSelect = document.getElementById("deviceSelect");
        if (deviceSelect.value) {
            connectDevice(); // Your existing function
            updateMidiBarStatus("connected", "Connected");
        } else {
            updateMidiBarStatus("ready", "");
        }
    }

    function updateMidiBarStatus(type, message) {
        const statusDot = document.getElementById("midiStatusDot");
        const statusText = document.getElementById("midiStatusText");

        if (statusDot && statusText) {
            statusDot.classList.remove("connected");
            statusText.textContent = message;

            if (type === "connected") {
                statusDot.classList.add("connected");
            }
        }
    }

    // Toggle arrangement controls menu
    function toggleArrangementControls() {
        const menu = document.getElementById("arrangementControlsMenu");
        const toggle = document.querySelector(".arrangement-controls-toggle");

        isArrangementMenuOpen = !isArrangementMenuOpen;

        if (isArrangementMenuOpen) {
            menu.classList.add("show");
            toggle.classList.add("active");
        } else {
            menu.classList.remove("show");
            toggle.classList.remove("active");
        }
    }

    // Close arrangement menu when clicking outside
    document.addEventListener("click", function (event) {
        const container = document.querySelector(
            ".arrangement-controls-container",
        );
        if (!container.contains(event.target) && isArrangementMenuOpen) {
            toggleArrangementControls();
        }
    });

    // Toggle piano controls menu
    function togglePianoControls() {
        const menu = document.getElementById("pianoControlsMenu");
        const toggle = document.querySelector(".piano-controls-toggle");

        isPianoMenuOpen = !isPianoMenuOpen;

        if (isPianoMenuOpen) {
            menu.classList.add("show");
            toggle.classList.add("active");
        } else {
            menu.classList.remove("show");
            toggle.classList.remove("active");
        }
    }

    // Close piano menu when clicking outside
    document.addEventListener("click", function (event) {
        const container = document.querySelector(".piano-controls-container");
        if (!container.contains(event.target) && isPianoMenuOpen) {
            togglePianoControls();
        }
    });

    function updateMidiBarVolume(value) {
        document.getElementById("volumeValue").textContent = value + "%";
        // Connect to your existing pianoSynth
        if (pianoSynth && pianoSynth.setVolume) {
            pianoSynth.setVolume(value);
        }
    }

    function updateMidiBarSound(value) {
        // Connect to your existing pianoSynth
        if (pianoSynth && pianoSynth.setSoundType) {
            pianoSynth.setSoundType(value);
        }
    }

    // Visualizer Functions
    function retryVisualizerConnection() {
        updateVisualizerStatus("waiting", "Retrying connection...");
        spectrumInstance = null;

        setTimeout(() => {
            if (connectMidiToSpectrum()) {
            } else {
                updateVisualizerStatus(
                    "error",
                    "Manual retry failed - check console",
                );
            }
        }, 500);
    }

    function updateVisualizerStatus(status, message) {
        const statusDot = document.getElementById("audioStatusDot");
        const statusText = document.getElementById("audioStatusText");
        const retryBtn = document.getElementById("retryBtn");

        if (statusDot && statusText) {
            statusDot.classList.remove("connected", "active");

            switch (status) {
                case "connected":
                    statusDot.classList.add("connected");
                    if (retryBtn) retryBtn.style.display = "none";
                    break;
                case "active":
                    statusDot.classList.add("active");
                    if (retryBtn) retryBtn.style.display = "none";
                    break;
                case "error":
                    if (retryBtn) retryBtn.style.display = "inline-block";
                    break;
                case "waiting":
                default:
                    if (retryBtn) retryBtn.style.display = "none";
                    break;
            }

            statusText.textContent = message;
        }
    }

    function connectMidiToSpectrum() {
        if (!spectrumInstance) {
            const containers = document.querySelectorAll(
                ".circular-spectrum-container",
            );
            for (let i = 0; i < containers.length; i++) {
                const container = containers[i];
                if (container.spectrumInstance) {
                    spectrumInstance = container.spectrumInstance;
                    break;
                }
            }
        }

        if (!spectrumInstance || !pianoSynth || !pianoSynth.audioContext) {
            const missing = [];
            if (!spectrumInstance) missing.push("spectrumInstance");
            if (!pianoSynth) missing.push("pianoSynth");
            if (!pianoSynth?.audioContext) missing.push("audioContext");

            updateVisualizerStatus("waiting", `Missing: ${missing.join(", ")}`);
            return false;
        }

        try {
            const tapGain = pianoSynth.audioContext.createGain();
            tapGain.gain.value = 1.0;

            pianoSynth.masterGain.connect(tapGain);

            if (!spectrumInstance.audioContext) {
                spectrumInstance.audioContext = pianoSynth.audioContext;
            }

            if (!spectrumInstance.analyser) {
                spectrumInstance.analyser =
                    pianoSynth.audioContext.createAnalyser();
                spectrumInstance.analyser.fftSize = 512;
                spectrumInstance.analyser.smoothingTimeConstant = 0.8;
            }

            tapGain.connect(spectrumInstance.analyser);
            spectrumInstance.dataArray = new Uint8Array(
                spectrumInstance.analyser.frequencyBinCount,
            );
            spectrumInstance.isAudioActive = true;

            if (typeof spectrumInstance.setStatusActive === "function") {
                spectrumInstance.setStatusActive(true);
            }

            if (typeof spectrumInstance.updateStatus === "function") {
                spectrumInstance.updateStatus("MIDI Connected");
            }

            updateVisualizerStatus("connected", "MIDI audio connected");
            return true;
        } catch (error) {
            console.error("‚ùå Failed to connect MIDI to spectrum:", error);
            updateVisualizerStatus(
                "error",
                `Connection failed: ${error.message}`,
            );
            return false;
        }
    }

    function findSpectrumInstance(attempt = 1) {
        const containers = document.querySelectorAll(
            ".circular-spectrum-container",
        );

        for (let i = 0; i < containers.length; i++) {
            const container = containers[i];
            if (container.spectrumInstance) {
                spectrumInstance = container.spectrumInstance;
                updateVisualizerStatus(
                    "waiting",
                    "Spectrum ready - connect MIDI device",
                );
                return true;
            }
        }

        if (attempt < 5) {
            updateVisualizerStatus(
                "waiting",
                `Loading visualizer... (${attempt}/5)`,
            );
            setTimeout(() => findSpectrumInstance(attempt + 1), 1000);
        } else {
            updateVisualizerStatus(
                "error",
                "Visualizer failed to load - try refresh",
            );
        }

        return false;
    }

    // üîß SIMPLE & SAFE: Just append user recording to arrangement without changing anything
    async function simpleCombineMidi(userMidiBlob, arrangementMidiBlob) {
        try {
            console.log(
                "üéº Simple combine: Adding user recording to arrangement...",
            );

            const { Midi } = await import(
                "https://cdn.skypack.dev/@tonejs/midi"
            );

            // Parse both files
            const userArrayBuffer = await userMidiBlob.arrayBuffer();
            const arrangementArrayBuffer =
                await arrangementMidiBlob.arrayBuffer();

            const userMidi = new Midi(userArrayBuffer);
            const arrangementMidi = new Midi(arrangementArrayBuffer);

            // üéØ KEY: Start with the arrangement MIDI exactly as-is
            const combinedMidi = new Midi(arrangementArrayBuffer); // Clone the arrangement

            console.log(
                `üéº Starting with arrangement (${arrangementMidi.tracks.length} tracks)`,
            );
            console.log(
                `üéº Adding user recording (${userMidi.tracks.length} tracks)`,
            );

            // üîÑ First: Create 8x looped user recording
            const singleLoopDuration = 9.6; // 16 beats at 100 BPM
            const totalLoops = 8;

            // Add user tracks as NEW tracks (don't modify existing arrangement tracks)
            userMidi.tracks.forEach((userTrack, index) => {
                const newUserTrack = combinedMidi.addTrack();
                newUserTrack.name = `User Recording ${index + 1} (8x Loop)`;
                newUserTrack.channel = 0; // Safe channel for user

                console.log(
                    `üîÑ Creating 8-loop user track: ${newUserTrack.name}`,
                );

                // Add 8 loops of the user recording
                for (let loop = 0; loop < totalLoops; loop++) {
                    const loopStartTime = loop * singleLoopDuration;

                    userTrack.notes.forEach((note) => {
                        if (note.time < singleLoopDuration) {
                            newUserTrack.addNote({
                                midi: note.midi,
                                time: note.time + loopStartTime,
                                duration: Math.min(
                                    note.duration,
                                    singleLoopDuration - note.time,
                                ),
                                velocity: note.velocity,
                            });
                        }
                    });

                    // Copy control changes for each loop
                    if (userTrack.controlChanges) {
                        Object.keys(userTrack.controlChanges).forEach(
                            (ccNumber) => {
                                userTrack.controlChanges[ccNumber].forEach(
                                    (cc) => {
                                        if (cc.time < singleLoopDuration) {
                                            newUserTrack.addCC({
                                                number: parseInt(ccNumber),
                                                value: cc.value,
                                                time: cc.time + loopStartTime,
                                            });
                                        }
                                    },
                                );
                            },
                        );
                    }
                }
            });

            // Convert to blob
            const combinedArray = combinedMidi.toArray();
            const combinedBlob = new Blob([combinedArray], {
                type: "audio/midi",
            });

            console.log(`‚úÖ Simple combined MIDI: ${combinedBlob.size} bytes`);
            console.log(
                `üéº Total tracks: ${combinedMidi.tracks.length} (arrangement preserved + user added)`,
            );

            return {
                blob: combinedBlob,
                trackCount: combinedMidi.tracks.length,
                userTracks: userMidi.tracks.length,
                arrangementTracks: arrangementMidi.tracks.length,
            };
        } catch (error) {
            console.error("‚ùå Simple combine failed:", error);
            return null;
        }
    }

    // üîß WORKING SOLUTION: Single player with toggle using different MIDI files
    async function createWorkingToggleSystem(
        userMidiBlob,
        arrangementMidiBlob,
    ) {
        try {
            console.log("üéõÔ∏è Creating working toggle system...");

            // 1. Create 8x looped user-only MIDI
            const loopedUserBlob = await create8LoopUserRecording(userMidiBlob);

            // 2. Create simple combined MIDI (arrangement + 8x user)
            const combinedResult = await simpleCombineMidi(
                userMidiBlob,
                arrangementMidiBlob,
            );

            if (!combinedResult) {
                throw new Error("Failed to create combined MIDI");
            }

            // 3. Store all three variations
            window.midiVariations = {
                combined: combinedResult.blob, // Arrangement + 8x User
                userOnly: loopedUserBlob, // 8x User only
                arrangementOnly: arrangementMidiBlob, // Arrangement only
            };

            // 4. Create URLs
            window.midiUrls = {
                combined: URL.createObjectURL(combinedResult.blob),
                userOnly: URL.createObjectURL(loopedUserBlob),
                arrangementOnly: URL.createObjectURL(arrangementMidiBlob),
            };

            console.log("‚úÖ Toggle system ready with 3 MIDI variations");
            return combinedResult;
        } catch (error) {
            console.error("‚ùå Toggle system creation failed:", error);
            return null;
        }
    }

    // üîß SIMPLIFIED: Show single player with working toggles
    function showMidiPlayer() {
        const combinedPlayer = document.getElementById("combinedTrackPlayer");
        const combinedMidiElement = document.getElementById(
            "combinedTrackMidiPlayer",
        );

        if (combinedPlayer && combinedMidiElement && window.midiUrls) {
            // Start with combined (both tracks)
            combinedMidiElement.src = window.midiUrls.combined;
            combinedPlayer.style.display = "flex";

            // Reset checkboxes to both checked
            document.getElementById("userTrackToggle").checked = true;
            document.getElementById("arrangementTrackToggle").checked = true;

            console.log("üéº Working combined player shown");
        }
    }

    // üîß WORKING: Update player source based on checkboxes
    function updateWorkingPlayerSource() {
        const userChecked = document.getElementById("userTrackToggle").checked;
        const arrangementChecked = document.getElementById(
            "arrangementTrackToggle",
        ).checked;
        const player = document.getElementById("combinedTrackMidiPlayer");

        if (!player || !window.midiUrls) return;

        let newSrc = "";
        let description = "";

        if (userChecked && arrangementChecked) {
            newSrc = window.midiUrls.combined;
            description = "Combined (User 8x + Arrangement)";
        } else if (userChecked && !arrangementChecked) {
            newSrc = window.midiUrls.userOnly;
            description = "User Recording Only (8x Loop)";
        } else if (!userChecked && arrangementChecked) {
            newSrc = window.midiUrls.arrangementOnly;
            description = "Arrangement Only";
        } else {
            player.stop();
            console.log("üéõÔ∏è Both tracks disabled - stopping playback");
            return;
        }

        // Check if source actually needs to change
        if (player.src === newSrc) {
            console.log("üéõÔ∏è Source unchanged:", description);
            return;
        }

        // Update source
        const wasPlaying = player.playing;
        const currentTime = player.currentTime || 0;

        player.stop();
        player.src = newSrc;

        console.log("üéõÔ∏è Switched to:", description);

        // Restart if it was playing
        if (wasPlaying) {
            setTimeout(() => {
                player.currentTime = currentTime;
                player.start();
            }, 100);
        }
    }

    // üîß UPDATE: Toggle functions to use working system
    function toggleUserTrack(enabled) {
        console.log(`üéµ User track ${enabled ? "enabled" : "disabled"}`);
        updateWorkingPlayerSource();
    }

    function toggleArrangementTrack(enabled) {
        console.log(`üéº Arrangement track ${enabled ? "enabled" : "disabled"}`);
        updateWorkingPlayerSource();
    }
    async function connectDevice() {
        const deviceSelect = document.getElementById("deviceSelect");
        if (!deviceSelect) return;

        const deviceId = deviceSelect.value;

        if (
            !deviceId ||
            deviceId.includes("No MIDI") ||
            deviceId.includes("Error") ||
            deviceId.includes("Web MIDI")
        ) {
            updateStatus(
                "midiStatus",
                "Please select a valid MIDI device",
                "error",
            );
            updateMidiBarStatus("error", "Invalid device");
            return;
        }

        if (!midiAccess || !midiAccess.inputs) {
            setTimeout(() => connectDevice(), 200);
            return;
        }

        try {
            await pianoSynth.init();

            const input = Array.from(midiAccess.inputs.values()).find(
                (inp) => inp.id === deviceId,
            );

            if (!input) {
                updateStatus(
                    "midiStatus",
                    "Selected MIDI device not found",
                    "error",
                );
                updateMidiBarStatus("error", "Device not found");
                return;
            }

            input.onmidimessage = handleMIDIMessage;
            midiInput = input;

            updateStatus(
                "midiStatus",
                "üéπ Piano connected! Studio-quality audio enabled",
                "ready",
            );
            updateMidiBarStatus("connected", "Connected"); // NEW LINE FOR STICKY BAR

            const pianoControls = document.getElementById("pianoControls");
            if (pianoControls) {
                pianoControls.style.display = "block";
            }

            console.log("üéπ Connected to MIDI device:", input.name);

            // Connect to visualizer
            updateVisualizerStatus("waiting", "Connecting to visualizer...");

            setTimeout(() => {
                if (!connectMidiToSpectrum()) {
                    setTimeout(() => {
                        if (!connectMidiToSpectrum()) {
                            setTimeout(() => {
                                if (!connectMidiToSpectrum()) {
                                    updateVisualizerStatus(
                                        "error",
                                        "Visualizer connection failed - MIDI audio still works",
                                    );
                                }
                            }, 2000);
                        }
                    }, 1000);
                }
            }, 500);
        } catch (error) {
            console.error("Error connecting to MIDI device:", error);
            updateStatus(
                "midiStatus",
                "Failed to connect to MIDI device",
                "error",
            );
            updateMidiBarStatus("error", "Connection failed"); // NEW LINE FOR STICKY BAR
        }
    }

    // üîß FIXED: Function to loop user recording 8 times
    async function create8LoopUserRecording(originalMidiBlob) {
        try {
            console.log("üîÑ Creating 8-loop version of user recording...");

            const { Midi } = await import(
                "https://cdn.skypack.dev/@tonejs/midi"
            );
            const arrayBuffer = await originalMidiBlob.arrayBuffer();
            const originalMidi = new Midi(arrayBuffer);

            // Create new MIDI with proper constructor options
            const loopedMidi = new Midi();

            // Copy tempo events
            if (
                originalMidi.header.tempos &&
                originalMidi.header.tempos.length > 0
            ) {
                originalMidi.header.tempos.forEach((tempo) => {
                    loopedMidi.header.setTempo(tempo.bpm, tempo.time);
                });
            } else {
                loopedMidi.header.setTempo(100, 0);
            }

            const singleLoopDuration = 9.6; // 16 beats at 100 BPM
            const totalLoops = 8;

            console.log(`üîÑ Creating ${totalLoops} loops of user recording`);

            originalMidi.tracks.forEach((originalTrack, trackIndex) => {
                const loopedTrack = loopedMidi.addTrack();

                if (originalTrack.name)
                    loopedTrack.name = originalTrack.name + " (8x Loop)";
                if (originalTrack.channel !== undefined)
                    loopedTrack.channel = originalTrack.channel;

                let totalNotesAdded = 0;

                for (let loop = 0; loop < totalLoops; loop++) {
                    const loopStartTime = loop * singleLoopDuration;

                    // Add notes for this loop
                    originalTrack.notes.forEach((note) => {
                        if (note.time < singleLoopDuration) {
                            loopedTrack.addNote({
                                midi: note.midi,
                                time: note.time + loopStartTime,
                                duration: Math.min(
                                    note.duration,
                                    singleLoopDuration - note.time,
                                ),
                                velocity: note.velocity,
                            });
                            totalNotesAdded++;
                        }
                    });

                    // Add control changes for this loop
                    if (originalTrack.controlChanges) {
                        Object.keys(originalTrack.controlChanges).forEach(
                            (ccNumber) => {
                                const ccArray =
                                    originalTrack.controlChanges[ccNumber];
                                ccArray.forEach((cc) => {
                                    if (cc.time < singleLoopDuration) {
                                        loopedTrack.addCC({
                                            number: parseInt(ccNumber),
                                            value: cc.value,
                                            time: cc.time + loopStartTime,
                                        });
                                    }
                                });
                            },
                        );
                    }
                }

                console.log(
                    `üîÑ Track ${trackIndex}: ${originalTrack.notes.length} ‚Üí ${totalNotesAdded} notes (${totalLoops}x)`,
                );
            });

            // Convert to blob
            const loopedMidiArray = loopedMidi.toArray();
            const loopedMidiBlob = new Blob([loopedMidiArray], {
                type: "audio/midi",
            });

            const totalDuration = singleLoopDuration * totalLoops;
            console.log(
                `‚úÖ 8-loop user recording created: ${loopedMidiBlob.size} bytes, ${totalDuration}s duration`,
            );

            return loopedMidiBlob;
        } catch (error) {
            console.error("‚ùå Failed to create 8-loop user recording:", error);
            return originalMidiBlob; // Fallback to original
        }
    }

    // üîß FIXED: Function to combine user recording with arrangement - NOW WITH 8x LOOPED USER TRACK
    async function combineMidiFiles(userMidiBlob, arrangementMidiBlob) {
        try {
            console.log(
                "üéº Combining 8x looped user recording with arrangement...",
            );

            // üîÑ STEP 1: Create 8x looped version of user recording
            const loopedUserBlob = await create8LoopUserRecording(userMidiBlob);

            const { Midi } = await import(
                "https://cdn.skypack.dev/@tonejs/midi"
            );

            // Parse both MIDI files (now using looped user recording)
            const userArrayBuffer = await loopedUserBlob.arrayBuffer();
            const arrangementArrayBuffer =
                await arrangementMidiBlob.arrayBuffer();

            const userMidi = new Midi(userArrayBuffer);
            const arrangementMidi = new Midi(arrangementArrayBuffer);

            // Create new combined MIDI
            const combinedMidi = new Midi();

            // Set tempo to 100 BPM
            combinedMidi.header.setTempo(100, 0);

            console.log(
                `üéº 8x Looped User tracks: ${userMidi.tracks.length}, Arrangement tracks: ${arrangementMidi.tracks.length}`,
            );

            // Add 8x looped user tracks first (Track 0 will be user input)
            userMidi.tracks.forEach((track, index) => {
                const combinedTrack = combinedMidi.addTrack();
                combinedTrack.name = `User Recording 8x Loop ${index + 1}`;
                combinedTrack.channel = 0; // User on channel 0

                // Copy all notes from 8x looped version
                track.notes.forEach((note) => {
                    combinedTrack.addNote({
                        midi: note.midi,
                        time: note.time,
                        duration: note.duration,
                        velocity: note.velocity,
                    });
                });

                // Copy control changes if any
                if (track.controlChanges) {
                    Object.keys(track.controlChanges).forEach((ccNumber) => {
                        track.controlChanges[ccNumber].forEach((cc) => {
                            combinedTrack.addCC({
                                number: parseInt(ccNumber),
                                value: cc.value,
                                time: cc.time,
                            });
                        });
                    });
                }
            });

            // Add arrangement tracks PRESERVING original channels and instruments
            arrangementMidi.tracks.forEach((track, index) => {
                const combinedTrack = combinedMidi.addTrack();
                combinedTrack.name = track.name || `Arrangement ${index + 1}`;

                // Keep original channel assignment
                combinedTrack.channel = track.channel;

                console.log(
                    `üîß Track "${combinedTrack.name}" using original channel: ${track.channel}`,
                );

                // Copy all notes
                track.notes.forEach((note) => {
                    combinedTrack.addNote({
                        midi: note.midi,
                        time: note.time,
                        duration: note.duration,
                        velocity: note.velocity,
                    });
                });

                // Copy ALL control changes (including program changes for instruments)
                if (track.controlChanges) {
                    Object.keys(track.controlChanges).forEach((ccNumber) => {
                        track.controlChanges[ccNumber].forEach((cc) => {
                            combinedTrack.addCC({
                                number: parseInt(ccNumber),
                                value: cc.value,
                                time: cc.time,
                            });
                        });
                    });
                }

                // Copy program changes (instrument selections)
                if (track.instrument) {
                    combinedTrack.instrument = track.instrument;
                }
            });

            // Convert to blob
            const combinedArray = combinedMidi.toArray();
            const combinedBlob = new Blob([combinedArray], {
                type: "audio/midi",
            });

            console.log(
                `‚úÖ Combined MIDI created with 8x looped user track: ${combinedBlob.size} bytes, ${combinedMidi.tracks.length} tracks`,
            );

            return {
                blob: combinedBlob,
                trackCount: combinedMidi.tracks.length,
                userTracks: userMidi.tracks.length,
                arrangementTracks: arrangementMidi.tracks.length,
                loopedUserBlob: loopedUserBlob, // Return this for separate user-only playback
            };
        } catch (error) {
            console.error("‚ùå Failed to combine MIDI files:", error);
            return null;
        }
    }

    // üîß FIXED: Create separate MIDI files for toggle functionality
    async function createToggleMidiFiles(
        userMidiBlob,
        arrangementMidiBlob,
        combinedResult,
    ) {
        try {
            // Store all variations
            window.midiVariations = {
                combined: combinedResult.blob,
                userOnly: combinedResult.loopedUserBlob, // 8x looped user recording
                arrangementOnly: arrangementMidiBlob,
            };

            // Create URLs for all variations
            window.midiUrls = {
                combined: URL.createObjectURL(combinedResult.blob),
                userOnly: URL.createObjectURL(combinedResult.loopedUserBlob),
                arrangementOnly: URL.createObjectURL(arrangementMidiBlob),
            };

            console.log(
                "üéõÔ∏è Created toggle MIDI variations: combined, userOnly, arrangementOnly",
            );
            return true;
        } catch (error) {
            console.error("‚ùå Failed to create toggle MIDI files:", error);
            return false;
        }
    }

    // üîß FIXED: Track Toggle Functions - Now swaps MIDI files instead of muting
    function updateCombinedPlayerSource() {
        const userChecked = document.getElementById("userTrackToggle").checked;
        const arrangementChecked = document.getElementById(
            "arrangementTrackToggle",
        ).checked;
        const player = document.getElementById("combinedTrackMidiPlayer");

        if (!player || !window.midiUrls) return;

        let newSrc = "";

        if (userChecked && arrangementChecked) {
            // Both enabled - use combined
            newSrc = window.midiUrls.combined;
            console.log("üéõÔ∏è Playing: Combined (User + Arrangement)");
        } else if (userChecked && !arrangementChecked) {
            // Only user - use 8x looped user recording
            newSrc = window.midiUrls.userOnly;
            console.log("üéõÔ∏è Playing: User Recording Only (8x Loop)");
        } else if (!userChecked && arrangementChecked) {
            // Only arrangement
            newSrc = window.midiUrls.arrangementOnly;
            console.log("üéõÔ∏è Playing: Arrangement Only");
        } else {
            // Neither - stop playback
            player.stop();
            console.log("üéõÔ∏è Both tracks disabled - stopping playback");
            return;
        }

        // Update player source
        const wasPlaying = player.playing;
        const currentTime = player.currentTime || 0;

        player.stop();
        player.src = newSrc;

        // Restart if it was playing
        if (wasPlaying) {
            // Small delay to ensure new source loads
            setTimeout(() => {
                player.currentTime = currentTime;
                player.start();
            }, 100);
        }
    }

    // üîß FIXED: Update showCombinedPlayer to create toggle files
    function showCombinedPlayer() {
        const combinedPlayer = document.getElementById("combinedTrackPlayer");
        const combinedMidiElement = document.getElementById(
            "combinedTrackMidiPlayer",
        );

        if (combinedPlayer && combinedMidiElement && window.combinedMidiUrl) {
            combinedMidiElement.src = window.combinedMidiUrl;
            combinedPlayer.style.display = "flex";

            // Reset checkboxes to both checked
            document.getElementById("userTrackToggle").checked = false;
            document.getElementById("arrangementTrackToggle").checked = true;

            console.log("üéº Combined player shown with both tracks enabled");
        }
    }

    // Initialize objects
    metronome = new Metronome();
    pianoSynth = new PianoSynth();
    midiRecorder = new MidiRecorder();

    function updateMidiDebugInfo(message) {
        const info = document.getElementById("midiPlayerInfo");
        if (info) {
            const timestamp = new Date().toLocaleTimeString();
            info.innerHTML += `[${timestamp}] ${message}<br>`;
            info.scrollTop = info.scrollHeight;
        }
    }

    // Web MIDI API Functions
    async function loadDevices() {
        try {
            if (!navigator.requestMIDIAccess) {
                updateMidiBarStatus("error", "Not supported");

                const mainSelect = document.getElementById("deviceSelect");
                if (mainSelect) {
                    mainSelect.innerHTML =
                        "<option>Web MIDI not supported</option>";
                }
                return;
            }

            midiAccess = await navigator.requestMIDIAccess();
            const inputs = Array.from(midiAccess.inputs.values());

            const mainSelect = document.getElementById("deviceSelect");

            if (!mainSelect) return;

            mainSelect.innerHTML = "";

            if (inputs.length === 0) {
                mainSelect.innerHTML =
                    '<option value="">No MIDI devices found</option>';
                updateMidiBarStatus("waiting", "No devices");
            } else {
                // Add default option
                mainSelect.innerHTML =
                    '<option value="">Select MIDI Device...</option>';

                // Add all devices
                inputs.forEach((input, index) => {
                    const option = document.createElement("option");
                    option.value = input.id;
                    option.textContent = `${input.name}`;
                    mainSelect.appendChild(option);
                });

                updateMidiBarStatus("waiting", "Select device");

                // SIMPLE AUTO-CONNECT: Back to what was working
                if (inputs.length > 0) {
                    mainSelect.value = inputs[0].id;
                    console.log(
                        "üéπ Auto-connecting to first MIDI device:",
                        inputs[0].name,
                    );

                    // Single attempt with the original timing
                    setTimeout(() => {
                        connectDevice();
                    }, 1000);
                }
            }

            console.log("üéπ Found MIDI inputs:", inputs.length);
        } catch (error) {
            console.error("Error accessing MIDI:", error);
            updateMidiBarStatus("error", "Access failed");

            const mainSelect = document.getElementById("deviceSelect");
            if (mainSelect) {
                mainSelect.innerHTML = "<option>Error loading devices</option>";
            }
        }
    }

    function handleMIDIMessage(message) {
        const [command, note, velocity] = message.data;
        const timestamp = performance.now();

        // Note On (command 144-159, velocity > 0)
        if (command >= 144 && command <= 159 && velocity > 0) {
            // Play sound with perfect quality
            pianoSynth.playNote(note, velocity);

            // Record note if recording
            if (midiRecorder.isRecording) {
                midiRecorder.addNote(note, velocity, timestamp, true);
            }
        }
        // Note Off (command 128-143 or command 144-159 with velocity 0)
        else if (
            (command >= 128 && command <= 143) ||
            (command >= 144 && command <= 159 && velocity === 0)
        ) {
            // Stop sound naturally
            pianoSynth.stopNote(note);

            // Record note off if recording
            if (midiRecorder.isRecording) {
                midiRecorder.addNote(note, 0, timestamp, false);
            }
        }
    }

    // Fixed recording control functions
    function toggleRecording() {
        console.log(
            "üîÑ Toggle recording called, current state:",
            midiRecorder?.isRecording,
        );

        if (midiRecorder && midiRecorder.isRecording) {
            // Currently recording - cancel it
            console.log("üõë Canceling current recording");
            cancelRecording();
        } else {
            // Not recording - start it
            console.log("‚ñ∂Ô∏è Starting new recording");
            startCapture();
        }
    }

    function startCapture() {
        if (!midiInput) {
            updateStatus(
                "captureStatus",
                "Please connect a MIDI device first",
                "error",
            );
            return;
        }

        // Clear any cached analysis results FIRST
        clearPreviousAnalysis();

        const enableMetronome = true;
        const tempo = 100;

        // Update button to "stop" state IMMEDIATELY
        updateRecordingButton(true);

        if (enableMetronome) {
            updateStatus("captureStatus", "ü•Å Counting in...", "analyzing");

            try {
                metronome.start(tempo, true);
            } catch (error) {
                console.error("Error starting metronome:", error);
                updateStatus(
                    "captureStatus",
                    "Metronome error - starting recording without metronome",
                    "error",
                );
                startDirectCapture();
            }
        } else {
            startDirectCapture();
        }
    }

    function startDirectCapture(predefinedDuration = null) {
        console.log(
            "üé¨ Starting direct capture, predefined duration:",
            predefinedDuration,
        );

        const mode = "time";

        // **CRITICAL FIX: Use the buffered duration for both internal and external timeouts**
        const exactDurationFor16Bars = 10.6; // 16 beats at 100 BPM = 9.6s + 0.5s buffer

        let duration;
        if (predefinedDuration) {
            // Use the buffered duration instead of the exact calculated one
            duration = exactDurationFor16Bars;
        } else {
            duration = exactDurationFor16Bars;
        }

        console.log(`üéµ Recording for ${duration.toFixed(1)}s (mode: ${mode})`);

        // Start MIDI recording with the BUFFERED duration
        midiRecorder.startRecording(mode, duration);

        updateStatus(
            "captureStatus",
            "üéµ Recording... Play your melody!",
            "recording",
        );

        // Clear any existing auto-stop timeout
        if (window.currentAutoStopTimeout) {
            clearTimeout(window.currentAutoStopTimeout);
            window.currentAutoStopTimeout = null;
        }

        // Backup external timeout (should match the internal one now)
        const autoStopTimeout = setTimeout(() => {
            console.log("‚è∞ External auto-stop backup fired");
            stopCapture();
        }, exactDurationFor16Bars * 1000);

        window.currentAutoStopTimeout = autoStopTimeout;

        // Monitor recording status
        const statusInterval = setInterval(() => {
            if (!midiRecorder.isRecording) {
                console.log("üìä Recording finished, processing...");
                clearInterval(statusInterval);

                if (window.currentAutoStopTimeout) {
                    clearTimeout(window.currentAutoStopTimeout);
                    window.currentAutoStopTimeout = null;
                }

                processRecordingResults();
            } else {
                const notes = midiRecorder.recordedNotes;
                const elapsedTime =
                    (performance.now() - midiRecorder.startTime) / 1000;
                updateStatus(
                    "captureStatus",
                    `üéµ Recording... ${notes.length} events, ${elapsedTime.toFixed(1)}s`,
                    "recording",
                );
            }
        }, 100);
    }

    function processRecordingResults() {
        // Reset button FIRST
        updateRecordingButton(false);

        // CRITICAL: Stop metronome when recording finishes naturally
        if (metronome && metronome.isPlaying) {
            metronome.stop();
            console.log("ü•Å Metronome stopped after recording completion");
        }

        // Check cancellation flag
        if (midiRecorder.wasCanceled) {
            console.log("üõë Recording was canceled - no processing");
            updateStatus("captureStatus", "üõë Recording canceled", "ready");
            return;
        }

        // Normal completion - process the recording
        const notes = midiRecorder.recordedNotes;
        updateStatus(
            "captureStatus",
            `‚úÖ Recording finished! ${notes.length} MIDI events captured`,
            "ready",
        );

        // Auto-analyze if notes were captured
        if (notes.length > 0) {
            updateStatus(
                "captureStatus",
                "üì§ Uploading recorded MIDI for analysis...",
                "analyzing",
            );
            uploadRecordedMIDI();
        }
    }

    function cancelRecording() {
        console.log("üõë Canceling recording - no processing will occur");

        // Clear any external timeouts
        if (window.currentAutoStopTimeout) {
            clearTimeout(window.currentAutoStopTimeout);
            window.currentAutoStopTimeout = null;
            console.log("üõë Cleared auto-stop timeout (canceled)");
        }

        // Stop metronome
        if (metronome) {
            metronome.stop();
        }

        // Cancel MIDI recording
        if (midiRecorder.isRecording) {
            midiRecorder.cancelRecording();
        }

        // Clear cached analysis results
        clearPreviousAnalysis();

        // Reset UI elements
        resetRecordingUI();

        // Reset button
        updateRecordingButton(false);

        updateStatus("captureStatus", "üõë Recording canceled", "ready");
    }

    function updateRecordingButton(isRecording) {
        const button = document.getElementById("recordToggleBtn");
        if (button) {
            if (isRecording) {
                button.textContent = "üü•";
                button.className = "stop-btn";
            } else {
                button.textContent = "üéôÔ∏è";
                button.className = "record-btn";
            }
            console.log("üîÑ Button updated:", button.textContent);
        }
    }

    function clearPreviousAnalysis() {
        // Clear any cached results
        window.uploadedMidiResult = null;

        // Clear overlay
        const progressions = document.getElementById("progressions");
        if (progressions) {
            progressions.innerHTML = "";
        }

        console.log("üóëÔ∏è Cleared previous analysis results");

        // Hide recorded track player when starting new recording
        const recordedPlayer = document.getElementById("recordedTrackPlayer");
        if (recordedPlayer) {
            recordedPlayer.style.display = "none";
        }

        // Clean up recorded track URLs
        if (recordedTrackUrl) {
            URL.revokeObjectURL(recordedTrackUrl);
            recordedTrackUrl = null;
        }
        recordedTrackBlob = null;

        // üÜï ADD THESE LINES AT THE END:
        // Hide looped track player when starting new recording
        const loopedPlayer = document.getElementById("loopedTrackPlayer");
        if (loopedPlayer) {
            loopedPlayer.style.display = "none";
        }

        // Clean up looped track URLs
        if (loopedTrackUrl) {
            URL.revokeObjectURL(loopedTrackUrl);
            loopedTrackUrl = null;
        }
        loopedTrackBlob = null;

        // Hide and clean up combined track player
        const combinedPlayer = document.getElementById("combinedTrackPlayer");
        if (combinedPlayer) {
            combinedPlayer.style.display = "none";
        }

        // Clean up combined track URLs
        if (window.combinedMidiUrl) {
            URL.revokeObjectURL(window.combinedMidiUrl);
            window.combinedMidiUrl = null;
        }
        window.combinedMidiBlob = null;
        window.combinedTrackInfo = null;
    }

    function resetRecordingUI() {
        // Reset beat indicator
        const beatCircle = document.getElementById("beatCircle");
        const beatCount = document.getElementById("beatCount");
        if (beatCircle && beatCount) {
            beatCircle.classList.remove("active", "count-in");
            beatCount.classList.remove("count-in", "recording");
            // beatCount.textContent = "Ready";
        }
    }

    // Fixed metronome startMIDIRecording method
    function fixMetronomeStartMIDIRecording() {
        // Replace the existing startMIDIRecording method
        metronome.startMIDIRecording = function () {
            console.log("üéµ Starting MIDI recording after count-in...");

            const currentTempo = 100; // Fixed tempo
            const beatsPerSecond = currentTempo / 60;
            const durationFor16Beats = 16 / beatsPerSecond;

            // Use exact duration without extra buffer for timing precision
            const exactDuration = durationFor16Beats;

            console.log(
                `Recording: ${exactDuration.toFixed(1)}s for 16 beats at ${currentTempo} BPM`,
            );

            // Start recording with exact duration - no additional timeouts needed
            setTimeout(() => {
                startDirectCapture(exactDuration);
            }, 50);
        };
    }

    async function extendMidiFile(originalBlob) {
        try {
            const formData = new FormData();
            formData.append("file", originalBlob, "original.mid");

            const response = await fetch(`${API_BASE}/extend-midi`, {
                method: "POST",
                body: formData,
            });

            if (!response.ok)
                throw new Error(`Extension failed: ${response.status}`);

            return await response.blob();
        } catch (error) {
            console.error("‚ùå Failed to extend MIDI:", error);
            return originalBlob; // Fallback to original
        }
    }

    // Fixed stopCapture function
    function stopCapture() {
        console.log("üõë Stop capture called");

        // Clear any external timeouts
        if (window.currentAutoStopTimeout) {
            clearTimeout(window.currentAutoStopTimeout);
            window.currentAutoStopTimeout = null;
        }

        // Stop metronome
        if (metronome) {
            metronome.stop();
        }

        // Stop MIDI recording normally (not cancel)
        if (midiRecorder.isRecording) {
            midiRecorder.stopRecording();
        }

        updateStatus("captureStatus", "‚èπÔ∏è Recording stopped", "ready");
    }

    // Enhanced uploadRecordedMIDI with duration fix integration
    async function uploadRecordedMIDI() {
        try {
            if (
                !midiRecorder.recordedNotes ||
                midiRecorder.recordedNotes.length === 0
            ) {
                throw new Error("No recorded notes to upload");
            }

            if (midiRecorder.wasCanceled) {
                console.log("üõë Upload blocked - recording was canceled");
                return;
            }

            updateStatus(
                "captureStatus",
                "üîß Creating MIDI files...",
                "analyzing",
            );

            // üìä UNCHANGED: Create original MIDI for backend analysis (don't touch this!)
            const originalMidiBlob = midiRecorder.convertToMidiBlob();
            console.log("üìä Original MIDI created for backend analysis");

            // üéØ STEP 1: Send original MIDI to backend (unchanged path)
            updateStatus(
                "captureStatus",
                "üì§ Analyzing recorded MIDI...",
                "analyzing",
            );

            const analysisFormData = new FormData();
            analysisFormData.append(
                "file",
                originalMidiBlob,
                "recorded_melody_analysis.mid",
            );

            const response = await fetch(`${API_BASE}/analyze/melody`, {
                method: "POST",
                body: analysisFormData,
            });

            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(
                    `Analysis failed: ${response.status} - ${errorText}`,
                );
            }

            const result = await response.json();
            console.log("‚úÖ Backend analysis complete:", result);

            // üéµ STEP 2: Create tempo-fixed MIDI for playback (NEW separate path)
            updateStatus(
                "captureStatus",
                "üîß Fixing tempo for playback...",
                "analyzing",
            );

            const fixedMidiBlob = await fixMidiTempo(originalMidiBlob, 100);
            console.log("üéµ Tempo-fixed MIDI created for playback");

            // üéµ STEP 3: Create 8-loop version for extended playback
            updateStatus(
                "captureStatus",
                "üîÑ Creating 8-loop version...",
                "analyzing",
            );

            const loopedMidiBlob = await create8LoopMidi(fixedMidiBlob);
            if (loopedMidiBlob) {
                loopedTrackBlob = loopedMidiBlob;

                if (loopedTrackUrl) {
                    URL.revokeObjectURL(loopedTrackUrl);
                }
                loopedTrackUrl = URL.createObjectURL(loopedMidiBlob);

                console.log("üîÑ 8-loop MIDI created for extended playback");
            } else {
                console.log("‚ö†Ô∏è Failed to create 8-loop version, skipping");
            }

            // Use the tempo-fixed MIDI for frontend playback
            recordedTrackBlob = fixedMidiBlob;

            if (recordedTrackUrl) {
                URL.revokeObjectURL(recordedTrackUrl);
            }
            recordedTrackUrl = URL.createObjectURL(fixedMidiBlob);

            // Show the player
            showRecordedTrackPlayer();

            updateStatus(
                "captureStatus",
                "‚úÖ Analysis Complete! Playback ready at 100 BPM",
                "ready",
            );

            // Display results (unchanged)
            displayAutoAnalysisResults(result);
            window.uploadedMidiResult = result;

            console.log("üéØ SUCCESS:");
            console.log("  üìä Original MIDI: Sent to backend (unchanged)");
            console.log("  üéµ Fixed MIDI: Ready for playback (100 BPM)");
        } catch (error) {
            console.error("‚ùå Error in MIDI process:", error);
            updateStatus("captureStatus", `Failed: ${error.message}`, "error");
        }
    }

    // üéµ NEW: Fix MIDI tempo using @tonejs/midi (much simpler!)
    async function fixMidiTempo(midiBlob, targetBPM) {
        try {
            console.log(
                `üîß Fixing MIDI tempo to ${targetBPM} BPM using @tonejs/midi...`,
            );

            // Import Tone.js MIDI (dynamically)
            const { Midi } = await import(
                "https://cdn.skypack.dev/@tonejs/midi"
            );

            // Convert blob to array buffer
            const arrayBuffer = await midiBlob.arrayBuffer();

            // Parse the MIDI file
            const midi = new Midi(arrayBuffer);

            console.log(
                `üîç Original MIDI: ${midi.tracks.length} tracks, ${midi.durationTicks} ticks`,
            );
            console.log(`üîç Original tempo events:`, midi.header.tempos);

            // Clear existing tempo events and set new one
            midi.header.tempos = [];
            midi.header.setTempo(targetBPM, 0); // Set 100 BPM at time 0

            // Ensure the duration is exactly 9.6 seconds (16 beats at 100 BPM)
            const targetDuration = 9.6;
            console.log(
                `üîß Setting duration to exactly ${targetDuration} seconds`,
            );

            // Extend or trim all tracks to the target duration
            midi.tracks.forEach((track, index) => {
                console.log(`üîß Track ${index}: ${track.notes.length} notes`);

                // Add a silent note at the target duration to ensure length
                if (track.notes.length > 0) {
                    track.addNote({
                        midi: 127, // High note out of the way
                        time: targetDuration - 0.1, // Just before the end
                        duration: 0.1,
                        velocity: 1, // Very quiet
                    });
                }
            });

            // Convert back to MIDI blob
            const fixedMidiArray = midi.toArray();
            const fixedMidiBlob = new Blob([fixedMidiArray], {
                type: "audio/midi",
            });

            console.log(
                `‚úÖ MIDI tempo fixed: ${targetBPM} BPM, ${targetDuration}s duration`,
            );
            console.log(`üîç Fixed MIDI size: ${fixedMidiBlob.size} bytes`);

            return fixedMidiBlob;
        } catch (error) {
            console.error("‚ùå Tempo fix failed:", error);
            console.log("üîÑ Falling back to original MIDI");
            return midiBlob; // Return original if fixing fails
        }
    }

    // üß™ TEST: Add this function to test the tempo fix
    async function testTempoFix() {
        if (!recordedTrackBlob) {
            console.log("‚ùå No recorded track to test");
            return;
        }

        console.log("üß™ Testing tempo-fixed MIDI...");

        try {
            const { Midi } = await import(
                "https://cdn.skypack.dev/@tonejs/midi"
            );
            const arrayBuffer = await recordedTrackBlob.arrayBuffer();
            const midi = new Midi(arrayBuffer);

            console.log("üîç Test Results:");
            console.log(
                `   Duration: ${midi.duration.toFixed(2)}s (expected: 9.6s)`,
            );
            console.log(`   Tempo events:`, midi.header.tempos);
            console.log(
                `   First tempo:`,
                midi.header.tempos[0]?.bpm || "None",
            );

            if (
                midi.header.tempos.length > 0 &&
                Math.abs(midi.header.tempos[0].bpm - 100) < 1
            ) {
                console.log("‚úÖ Tempo fix SUCCESS!");
            } else {
                console.log("‚ùå Tempo fix FAILED");
            }
        } catch (error) {
            console.error("‚ùå Test failed:", error);
        }
    }

    // üéØ NEW: Test function to verify duration fix is working
    async function testDurationFix() {
        const player = document.getElementById("recordedTrackMidiPlayer");
        if (player && player.src) {
            console.log("üß™ Testing duration fix...");

            player.addEventListener("stop", function testListener() {
                const duration = player.currentTime || 0;
                console.log(
                    `üß™ Test result: Player stopped at ${duration.toFixed(2)}s`,
                );

                if (Math.abs(duration - 9.6) < 0.1) {
                    console.log("‚úÖ Duration fix successful!");
                    updateStatus(
                        "captureStatus",
                        "‚úÖ Duration fix verified: 9.6s",
                        "ready",
                    );
                } else {
                    console.log(
                        `‚ùå Duration fix failed: expected 9.6s, got ${duration.toFixed(2)}s`,
                    );
                    updateStatus(
                        "captureStatus",
                        `‚ùå Duration fix failed: ${duration.toFixed(2)}s`,
                        "error",
                    );
                }

                // Remove this test listener
                player.removeEventListener("stop", testListener);
            });

            // Start and let it play to completion
            player.start();
            updateStatus(
                "captureStatus",
                "üß™ Testing 9.6s duration...",
                "analyzing",
            );
        } else {
            console.log("‚ùå No recorded track to test");
        }
    }

    // üéØ NEW: Add test button to your recorded track controls
    function addDurationTestButton() {
        const recordedControls = document.querySelector(
            ".recorded-track-controls",
        );
        if (recordedControls) {
            const testBtn = document.createElement("button");
            testBtn.className = "mini-midi-btn";
            testBtn.innerHTML = "üß™";
            testBtn.title = "Test 9.6s Duration";
            testBtn.onclick = testDurationFix;
            recordedControls.appendChild(testBtn);
            console.log("üß™ Duration test button added");
        }
    }

    function simplifyChordProgression(chords) {
        // Check if we have an even number of chords
        if (chords.length % 2 !== 0) {
            return chords; // Can't be all pairs if odd number
        }

        // Check if all consecutive pairs are the same
        let allPairs = true;
        for (let i = 0; i < chords.length; i += 2) {
            if (chords[i] !== chords[i + 1]) {
                allPairs = false;
                break;
            }
        }

        // If all pairs, return simplified version
        if (allPairs) {
            const simplified = [];
            for (let i = 0; i < chords.length; i += 2) {
                simplified.push(chords[i]);
            }
            console.log(
                "üéµ Simplified doubled progression:",
                chords.join(" ‚Üí "),
                "to:",
                simplified.join(" ‚Üí "),
            );
            return simplified;
        }

        return chords; // Return original if not all pairs
    }

    // Fixed auto analysis display with proper fresh result handling
    function displayAutoAnalysisResults(result) {
        const progressions = document.getElementById("progressions");
        if (!progressions) return;

        // Verify we have a valid result
        if (!result) {
            console.log("‚ö†Ô∏è No result to display");
            return;
        }

        const detectedType = result.detected_type || "unknown";
        console.log("üéº Displaying analysis results for type:", detectedType);

        let chords = [];

        if (detectedType === "chord_progression") {
            chords = result.chord_progression || ["C", "F", "G", "C"];
        } else {
            if (result.harmonizations && result.harmonizations.simple_pop) {
                chords = result.harmonizations.simple_pop.progression || [
                    "C",
                    "F",
                    "G",
                    "C",
                ];
            } else {
                chords = ["C", "F", "G", "C"];
            }
        }

        const simplifiedChords = simplifyChordProgression(chords);

        // Display the chord progression
        if (simplifiedChords && simplifiedChords.length > 0) {
            progressions.innerHTML = simplifiedChords.join(" ‚Üí ");
            console.log(
                "‚úÖ Progression displayed:",
                simplifiedChords.join(" ‚Üí "),
            );
        } else {
            console.log("‚ö†Ô∏è No valid chords to display");
        }
    }

    // Fixed analyzeAndGenerate - handles both chord progression and melody results
    async function analyzeAndGenerate() {
        if (!window.uploadedMidiResult) {
            updateStatus(
                "captureStatus",
                "Please record a melody first",
                "error",
            );
            return;
        }

        // Get values from sticky bar (fallback to main form if sticky bar elements don't exist)
        const harmonySelect =
            document.getElementById("stickyHarmonyStyle") ||
            document.getElementById("harmonyStyle");
        const bassSlider =
            document.getElementById("stickyBassComplexity") ||
            document.getElementById("bassComplexity");
        const drumSlider =
            document.getElementById("stickyDrumComplexity") ||
            document.getElementById("drumComplexity");

        if (!harmonySelect || !bassSlider || !drumSlider) return;

        const style = harmonySelect.value;
        const bassComplexity = parseInt(bassSlider.value);
        const drumComplexity = parseInt(drumSlider.value);

        // Disable generate button during processing
        const generateBtn = document.getElementById("stickyGenerateBtn");
        if (generateBtn) {
            generateBtn.disabled = true;
            generateBtn.textContent = "üéµ Generating...";
        }

        updateStatus(
            "captureStatus",
            "üéµ Generating full arrangement...",
            "analyzing",
        );

        try {
            const result = window.uploadedMidiResult;
            const detectedType = result.detected_type || "melody";

            console.log(
                "üîß DEBUG: Detected type for arrangement:",
                detectedType,
            );
            console.log("üîß DEBUG: Full result object:", result);

            let selectedProgression;
            let styleMap = {};

            if (detectedType === "chord_progression") {
                // CHORD PROGRESSION PATH - Use the detected progression
                console.log(
                    "üéº Using detected chord progression for arrangement",
                );
                selectedProgression = result.chord_progression || [
                    "C",
                    "F",
                    "G",
                    "C",
                    "Am",
                    "F",
                    "G",
                    "C",
                ];

                // For chord progressions, all "styles" use the same detected progression
                styleMap = {
                    simple_pop: selectedProgression,
                    folk_acoustic: selectedProgression,
                    bass_foundation: selectedProgression,
                    phrase_foundation: selectedProgression,
                };

                console.log("üîß Using chord progression:", selectedProgression);
            } else {
                // MELODY PATH - Use harmonizations as before
                console.log("üéº Using melody harmonizations for arrangement");

                if (!result.harmonizations) {
                    throw new Error("No harmonizations found in melody result");
                }

                styleMap = {
                    simple_pop: result.harmonizations.simple_pop
                        ?.progression || [
                        "C",
                        "F",
                        "G",
                        "C",
                        "Am",
                        "F",
                        "G",
                        "C",
                    ],
                    folk_acoustic: result.harmonizations.folk_acoustic
                        ?.progression || [
                        "C",
                        "F",
                        "G",
                        "C",
                        "Am",
                        "F",
                        "G",
                        "C",
                    ],
                    bass_foundation: result.harmonizations.bass_foundation
                        ?.progression || [
                        "C",
                        "F",
                        "G",
                        "C",
                        "Am",
                        "F",
                        "G",
                        "C",
                    ],
                    phrase_foundation: result.harmonizations.phrase_foundation
                        ?.progression || [
                        "C",
                        "F",
                        "G",
                        "C",
                        "Am",
                        "F",
                        "G",
                        "C",
                    ],
                };

                selectedProgression = styleMap[style];
                console.log("üîß Selected harmonization style:", style);
            }

            console.log(
                "üîß Sending request with progression:",
                selectedProgression,
            );

            // Generate arrangement from the chord progression
            const response = await fetch(`${API_BASE}/generate/arrangement`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                    chord_progression: selectedProgression,
                    bpm: 100,
                    bass_complexity: bassComplexity,
                    drum_complexity: drumComplexity,
                    hi_hat_divisions: 2,
                    snare_beats: [2, 4],
                }),
            });

            if (!response.ok) {
                const errorText = await response.text();
                console.error("Backend error response:", errorText);
                throw new Error(
                    `Server error: ${response.status} - ${errorText}`,
                );
            }

            const arrangementResult = await response.json();

            console.log(
                "üîß Backend response full object:",
                JSON.stringify(arrangementResult, null, 2),
            );
            console.log(
                "üîß Backend output_file field:",
                arrangementResult.output_file,
            );

            if (arrangementResult.output_file) {
                console.log(
                    "üîß DEBUG: recordedTrackBlob exists?",
                    !!recordedTrackBlob,
                );
                console.log(
                    "üîß DEBUG: recordedTrackBlob size:",
                    recordedTrackBlob?.size,
                );
                // NEW: Initialize unified player if we have a user recording
                // NEW: Create working toggle system if we have a user recording
                if (recordedTrackBlob) {
                    updateStatus(
                        "captureStatus",
                        "üéº Creating toggle system...",
                        "analyzing",
                    );

                    try {
                        // Handle both forward slashes and backslashes from backend
                        const filename = arrangementResult.output_file
                            .split(/[/\\]/)
                            .pop();
                        const arrangementPath = `/generated_arrangements/${filename}`;

                        console.log(
                            "üîß Fetching arrangement from:",
                            arrangementPath,
                        );

                        const arrangementResponse =
                            await fetch(arrangementPath);

                        if (arrangementResponse.ok) {
                            const arrangementBlob =
                                await arrangementResponse.blob();
                            console.log(
                                "üîß Arrangement blob size:",
                                arrangementBlob.size,
                                "bytes",
                            );

                            const toggleResult =
                                await createWorkingToggleSystem(
                                    recordedTrackBlob,
                                    arrangementBlob,
                                );

                            if (toggleResult) {
                                // Store for the UI
                                window.combinedMidiBlob = toggleResult.blob;
                                window.combinedMidiUrl =
                                    window.midiUrls.combined;
                                window.combinedTrackInfo = toggleResult;

                                // Show working combined player
                                showMidiPlayer();

                                console.log(
                                    `üéº Working toggle system ready: ${toggleResult.userTracks} user + ${toggleResult.arrangementTracks} arrangement tracks`,
                                );

                                updateStatus(
                                    "captureStatus",
                                    "‚úÖ Toggle system ready!",
                                    "ready",
                                );

                                // üÜï ADD THIS LINE HERE:
                                if (window.voiceCommands) {
                                    window.voiceCommands.onArrangementComplete();
                                }

                                // üîß ADD THIS: Re-enable generate button
                                if (generateBtn) {
                                    generateBtn.disabled = false;
                                    generateBtn.textContent = "üéµ Generate";
                                }
                            } else {
                                console.error(
                                    "‚ùå Failed to create toggle system",
                                );
                                // üîß ADD THIS: Re-enable generate button on failure too
                                if (generateBtn) {
                                    generateBtn.disabled = false;
                                    generateBtn.textContent = "üéµ Generate";
                                }
                            }
                        } else {
                            console.error(
                                "‚ùå Failed to fetch arrangement file:",
                                arrangementResponse.status,
                            );
                        }
                    } catch (error) {
                        console.error(
                            "‚ùå Failed to create toggle system:",
                            error,
                        );
                    }
                }

                // Create result object for display (handle both types)
                let keyConfidence = 0.75; // Default confidence

                if (detectedType === "melody" && result.harmonizations) {
                    // Calculate confidence from harmonizations
                    const confidences = Object.values(result.harmonizations)
                        .map((h) => h?.confidence || 0)
                        .filter((c) => c > 0);
                    keyConfidence =
                        confidences.length > 0
                            ? Math.max(...confidences) / 100
                            : 0.75;
                }

                const fullResult = {
                    success: true,
                    key: result.key || "C",
                    key_confidence: keyConfidence,
                    chord_progressions: styleMap,
                    arrangement_file: arrangementResult.output_file
                        .split("/")
                        .pop(), // Just filename for download link
                    visualization_file: null,
                    visualization_url: null,
                    detected_type: detectedType,
                    analysis_path: result.analysis_path || detectedType,
                };

                updateStatus(
                    "analysisStatus",
                    "‚úÖ Analysis and arrangement complete!",
                    "ready",
                );
                displayFullResults(fullResult);
            } else {
                console.error("No output_file in response:", arrangementResult);
                updateStatus(
                    "analysisStatus",
                    `‚ùå ${arrangementResult.message || "No arrangement file returned"}`,
                    "error",
                );
            }
        } catch (error) {
            console.error("Error in analyzeAndGenerate:", error);
            updateStatus(
                "analysisStatus",
                `Analysis error: ${error.message}`,
                "error",
            );
        }
    }

    // Display Functions
    function displayFullResults(result) {
        const resultsSection = document.getElementById("results");
        const keyInfo = document.getElementById("keyInfo");
        const progressions = document.getElementById("progressions");
        const arrangementLink = document.getElementById("arrangementLink");
        const visualizationLink = document.getElementById("visualizationLink");

        if (
            !resultsSection ||
            !keyInfo ||
            !progressions ||
            !arrangementLink ||
            !visualizationLink
        )
            return;

        resultsSection.style.display = "block";

        keyInfo.innerHTML = `<strong>Detected Key:</strong> ${result.key} (confidence: ${result.key_confidence.toFixed(2)})`;

        let progressionsHtml = "<h4>Chord Progressions:</h4>";
        Object.entries(result.chord_progressions).forEach(([style, chords]) => {
            progressionsHtml += `<div>
                <strong>${style}:</strong> 
                <div class="chord-progression">${chords.join(" ‚Üí ")}</div>
            </div>`;
        });
        progressions.innerHTML = progressionsHtml;

        if (result.arrangement_file) {
            arrangementLink.innerHTML = `<strong>Generated Arrangement:</strong> <a href="/generated_arrangements/${result.arrangement_file}" download>üì• Download MIDI (${result.arrangement_file})</a>`;
        } else {
            arrangementLink.innerHTML =
                "<em>No arrangement file generated</em>";
        }

        if (result.visualization_file) {
            visualizationLink.innerHTML = `<strong>Visualization:</strong> <a href="${API_BASE}${result.visualization_url}" target="_blank" rel="noopener">üìä View Chord Progression Chart</a>`;
        } else {
            visualizationLink.innerHTML = "";
        }
    }

    // Utility Functions
    function updateStatus(elementId, message, type) {
        const element = document.getElementById(elementId);
        if (!element) return;

        element.textContent = message;
        element.className = `status ${type}`;
    }

    function showRecordedTrackPlayer() {
        const player = document.getElementById("recordedTrackMidiPlayer");
        if (player) {
            player.stop();
            player.currentTime = 0;
            console.log("‚èπÔ∏è Stopped recorded track");
        }
    }

    function playCombinedTrack() {
        const player = document.getElementById("combinedTrackMidiPlayer");
        if (player && player.src) {
            player.start();
            console.log("üéº Started playing combined track");
        }
    }

    function stopCombinedTrack() {
        const player = document.getElementById("combinedTrackMidiPlayer");
        if (player) {
            player.stop();
            player.currentTime = 0;
        }
    }

    function toggleCombinedTrackLoop() {
        const player = document.getElementById("combinedTrackMidiPlayer");
        if (player) {
            player.loop = !player.loop;
            console.log("Combined track loop:", player.loop ? "ON" : "OFF");
        }
    }

    // üîß SMART DOWNLOAD: Downloads whatever is currently playing
    function saveCombinedTrack() {
        const userChecked = document.getElementById("userTrackToggle").checked;
        const arrangementChecked = document.getElementById(
            "arrangementTrackToggle",
        ).checked;

        let downloadBlob, downloadUrl, filename;
        const timestamp = new Date()
            .toISOString()
            .slice(0, 19)
            .replace(/:/g, "-");

        if (userChecked && arrangementChecked) {
            // Both enabled - download combined
            downloadBlob = window.midiVariations.combined;
            downloadUrl = window.midiUrls.combined;
            filename = `combined_track_${timestamp}.mid`;
            console.log("üíæ Downloading combined track (User + Arrangement)");
        } else if (userChecked && !arrangementChecked) {
            // Only user - download 8x looped user recording
            downloadBlob = window.midiVariations.userOnly;
            downloadUrl = window.midiUrls.userOnly;
            filename = `your_recording_8x_loop_${timestamp}.mid`;
            console.log("üíæ Downloading your recording (8x Loop)");
        } else if (!userChecked && arrangementChecked) {
            // Only arrangement - download arrangement only
            downloadBlob = window.midiVariations.arrangementOnly;
            downloadUrl = window.midiUrls.arrangementOnly;
            filename = `arrangement_only_${timestamp}.mid`;
            console.log("üíæ Downloading arrangement only");
        } else {
            // Neither checked - show message and download combined as fallback
            console.log(
                "‚ö†Ô∏è No tracks selected, downloading combined as fallback",
            );
            downloadBlob = window.midiVariations.combined;
            downloadUrl = window.midiUrls.combined;
            filename = `combined_track_fallback_${timestamp}.mid`;
        }

        // Perform the download
        if (downloadUrl) {
            const link = document.createElement("a");
            link.href = downloadUrl;
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);

            console.log(`‚úÖ Downloaded: ${filename}`);
        } else {
            console.log("‚ùå No file available to download");
        }
    }

    // Initialize everything
    document.addEventListener("DOMContentLoaded", function () {
        console.log("üöÄ DOM loaded, initializing...");

        // Initialize objects
        pianoSynth = new PianoSynth();
        midiRecorder = new MidiRecorder();

        // Start spectrum detection
        setTimeout(() => findSpectrumInstance(), 1000);

        // Load MIDI devices
        loadDevices();

        // Setup event listeners for sliders
        const bassComplexity = document.getElementById("bassComplexity");
        const drumComplexity = document.getElementById("drumComplexity");
        const bassValue = document.getElementById("bassValue");
        const drumValue = document.getElementById("drumValue");

        if (bassComplexity && bassValue) {
            bassComplexity.addEventListener("input", function (e) {
                bassValue.textContent = e.target.value;
            });
        }

        if (drumComplexity && drumValue) {
            drumComplexity.addEventListener("input", function (e) {
                drumValue.textContent = e.target.value;
            });
        }

        // Update slider values
        const stickyBassComplexity = document.getElementById(
            "stickyBassComplexity",
        );
        const stickyDrumComplexity = document.getElementById(
            "stickyDrumComplexity",
        );
        const stickyBassValue = document.getElementById("stickyBassValue");
        const stickyDrumValue = document.getElementById("stickyDrumValue");

        if (stickyBassComplexity && stickyBassValue) {
            stickyBassComplexity.addEventListener("input", function (e) {
                stickyBassValue.textContent = e.target.value;
            });
        }

        if (stickyDrumComplexity && stickyDrumValue) {
            stickyDrumComplexity.addEventListener("input", function (e) {
                stickyDrumValue.textContent = e.target.value;
            });
        }

        // Piano controls
        const pianoVolume = document.getElementById("pianoVolume");
        const pianoSound = document.getElementById("pianoSound");
        const volumeValue = document.getElementById("volumeValue");

        if (pianoVolume && volumeValue) {
            pianoVolume.addEventListener("input", function (e) {
                const volume = parseInt(e.target.value);
                volumeValue.textContent = volume + "%";
                pianoSynth.setVolume(volume);
            });
        }

        if (pianoSound) {
            pianoSound.addEventListener("change", function (e) {
                pianoSynth.setSoundType(e.target.value);
            });
        }

        // At the end of your existing DOMContentLoaded function, add:
        setTimeout(() => {
            if (metronome) {
                fixMetronomeStartMIDIRecording();
                console.log("üîß Metronome startMIDIRecording method fixed");
            }
        }, 1000);

        // Initialize voice commands and precision MIDI controls
        setTimeout(() => {
            voiceCommands = new VoiceCommands();
            window.voiceCommands = voiceCommands;

            // üé≠ LOAD VOICES EARLY:
            speechSynthesis.getVoices(); // Trigger voice loading

            voiceCommands.startListening();
            console.log(
                'üé§ Voice commands initialized - say "Hey Wave" to activate',
            );
        }, 2000);
    });

    // Global exports
    window.connectDevice = connectDevice;
    window.loadDevices = loadDevices;
    window.autoConnect = autoConnect;
    window.retryVisualizerConnection = retryVisualizerConnection;

    window.startCapture = startCapture;
    window.stopCapture = stopCapture;

    window.cancelRecording = cancelRecording;
    window.toggleRecording = toggleRecording;

    window.analyzeAndGenerate = analyzeAndGenerate;

    window.togglePianoControls = togglePianoControls;
    window.toggleArrangementControls = toggleArrangementControls;

    window.updateMidiBarVolume = updateMidiBarVolume;
    window.updateMidiBarSound = updateMidiBarSound;
    window.updateMidiBarStatus = updateMidiBarStatus;

    window.playCombinedTrack = playCombinedTrack;
    window.stopCombinedTrack = stopCombinedTrack;
    window.toggleCombinedTrackLoop = toggleCombinedTrackLoop;
    window.saveCombinedTrack = saveCombinedTrack;

    window.toggleUserTrack = toggleUserTrack;
    window.toggleArrangementTrack = toggleArrangementTrack;
    window.updateWorkingPlayerSource = updateWorkingPlayerSource;
    window.showMidiPlayer = showMidiPlayer;
</script>
