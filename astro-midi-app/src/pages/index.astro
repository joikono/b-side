---
// index.astro - Frontend-Only MIDI Analysis Demo with Integrated Player
// Perfect audio quality with Web MIDI API + Web Audio API + MIDI Playback
const apiBase = "http://localhost:8000";
// import '../styles/global.css';
import CircularWaveform from "../components/circular_waveform.astro";
---

<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- Load the proven html-midi-player library -->
        <script
            src="https://cdn.jsdelivr.net/combine/npm/tone@14.7.58,npm/@magenta/music@1.23.1/es6/core.js,npm/focus-visible@5,npm/html-midi-player@1.4.0"
        ></script>
        <script src="https://cdn.skypack.dev/@tonejs/midi"></script>
    </head>
    <body>
        <!-- Full-Screen Waveform Centerpiece -->
        <div class="waveform-centerpiece">
            <div id="progressions" class="progression-overlay"></div>
            <CircularWaveform
                width="100vw"
                height="100vh"
                radius="40"
                maxBarHeight="30"
                barCount="128"
                showControls={false}
                className="spectrum-canvas"
            />
        </div>

        <!-- Overlay Controls (Minimal) -->
        <div class="overlay-controls">
            <!-- Visualizer status in corner -->
            <div class="corner-status" id="visualizerStatus">
                <span class="status-dot" id="audioStatusDot"></span>
                <span id="audioStatusText">Ready</span>
            </div>
        </div>

        <!-- Sticky MIDI Control Bar -->
        <div class="midi-control-bar">
            <div class="midi-bar-content">
                <!-- LEFT SECTION: Arrangement Controls -->
                <div class="left-controls">
                    <!-- Compact MIDI Player (initially hidden) - positioned above arrangement controls -->
                    <div
                        id="stickyMidiPlayer"
                        class="sticky-midi-player"
                        style="display: none;"
                    >
                        <midi-player
                            id="stickyArrangementPlayer"
                            src=""
                            sound-font="https://storage.googleapis.com/magentadata/js/soundfonts/sgm_plus"
                            loop
                        >
                        </midi-player>
                        <div class="sticky-midi-controls">
                            <button
                                onclick="stopStickyMidi()"
                                class="mini-midi-btn">‚èπÔ∏è</button
                            >
                            <button
                                onclick="toggleStickyMidiLoop()"
                                class="mini-midi-btn">üîÑ</button
                            >
                            <button
                                onclick="downloadCurrentMidi()"
                                class="mini-midi-btn download-btn"
                                title="Download MIDI">üíæ</button
                            >
                        </div>
                    </div>
                    <div
                        id="recordedTrackPlayer"
                        class="recorded-track-player"
                        style="display: none;"
                    >
                        <midi-player
                            id="recordedTrackMidiPlayer"
                            src=""
                            sound-font="https://storage.googleapis.com/magentadata/js/soundfonts/sgm_plus"
                            loop
                        >
                        </midi-player>
                        <div class="recorded-track-controls">
                            <button
                                onclick="stopRecordedTrack()"
                                class="mini-midi-btn">‚èπÔ∏è</button
                            >
                            <button
                                onclick="toggleRecordedTrackLoop()"
                                class="mini-midi-btn">üîÑ</button
                            >
                            <button
                                onclick="saveRecordedTrack()"
                                class="mini-midi-btn download-btn"
                                title="Save Recording">üíæ</button
                            >
                        </div>
                    </div>

                    <!-- Arrangement controls in horizontal wrapper -->
                    <div class="arrangement-controls-container">
                        <button
                            class="arrangement-controls-toggle"
                            onclick="toggleArrangementControls()"
                            title="Arrangement Settings"
                        >
                            üéº
                        </button>
                        <!-- Expandable Arrangement Menu -->
                        <div
                            id="arrangementControlsMenu"
                            class="arrangement-controls-menu"
                        >
                            <div class="control-group">
                                <label>Style:</label>
                                <select id="stickyHarmonyStyle">
                                    <option value="simple_pop"
                                        >Simple/Pop</option
                                    >
                                    <option value="folk_acoustic"
                                        >Folk/Acoustic</option
                                    >
                                    <option value="bass_foundation"
                                        >Bass Foundation</option
                                    >
                                    <option value="phrase_foundation"
                                        >Phrase Foundation</option
                                    >
                                </select>
                            </div>
                            <div class="control-group">
                                <label>Bass:</label>
                                <input
                                    type="range"
                                    id="stickyBassComplexity"
                                    min="1"
                                    max="3"
                                    value="1"
                                />
                                <span id="stickyBassValue">1</span>
                            </div>
                            <div class="control-group">
                                <label>Drums:</label>
                                <input
                                    type="range"
                                    id="stickyDrumComplexity"
                                    min="1"
                                    max="3"
                                    value="1"
                                />
                                <span id="stickyDrumValue">1</span>
                            </div>
                        </div>
                    </div>

                    <!-- Generate Arrangement Button -->
                    <button
                        id="stickyGenerateBtn"
                        class="generate-arrangement-btn"
                        onclick="analyzeAndGenerate()"
                        title="Generate Full Arrangement"
                    >
                        üéµ Generate
                    </button>
                </div>

                <!-- CENTER SECTION: Piano Controls -->
                <div class="center-controls">
                    <div class="piano-controls-container">
                        <button
                            class="piano-controls-toggle"
                            onclick="togglePianoControls()"
                            title="Piano Settings"
                        >
                            üéπ
                        </button>
                        <!-- Expandable Piano Menu -->
                        <div id="pianoControlsMenu" class="piano-controls-menu">
                            <div class="midi-device-section">
                                <select
                                    id="deviceSelect"
                                    class="midi-dropdown"
                                    onchange="autoConnect()"
                                >
                                    <option value=""
                                        >Select MIDI Device...</option
                                    >
                                </select>
                                <button
                                    class="refresh-btn"
                                    onclick="loadDevices()"
                                    title="Refresh Devices"
                                >
                                    üîÑ
                                </button>
                            </div>
                            <div class="control-group">
                                <label>Volume:</label>
                                <input
                                    type="range"
                                    id="pianoVolume"
                                    min="0"
                                    max="100"
                                    value="10"
                                    oninput="updateMidiBarVolume(this.value)"
                                />
                                <span id="volumeValue">10%</span>
                            </div>
                            <div class="control-group">
                                <label>Sound:</label>
                                <select
                                    id="pianoSound"
                                    onchange="updateMidiBarSound(this.value)"
                                >
                                    <option value="piano">Piano</option>
                                    <option value="electric">Electric</option>
                                    <option value="organ">Organ</option>
                                    <option value="synth">Synth</option>
                                </select>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- RIGHT SECTION: Record & Metronome -->
                <div class="right-controls">
                    <div class="button-group">
                        <button
                            id="recordToggleBtn"
                            class="record-btn"
                            onclick="toggleRecording()"
                        >
                            üéôÔ∏è
                        </button>
                    </div>
                    <div id="beatIndicator" class="beat-indicator">
                        <div class="beat-circle" id="beatCircle"></div>
                        <div class="beat-count" id="beatCount"></div>
                    </div>
                </div>
            </div>
        </div>
    </body>
</html>

<script>
    // @ts-nocheck

    // API Configuration
    const API_BASE = "http://localhost:8000";

    // Global variables
    let metronome;
    let pianoSynth;
    let midiAccess;
    let midiInput;
    let midiRecorder;
    let spectrumInstance = null;
    let isPianoMenuOpen = false;

    // MIDI Player variables
    let midiPlayer;
    let isMidiLooping = false;
    let baseBPM = 100;
    const defaultBPM = 120;
    const beatsPerLoop = 16;
    let midiCheckLoopInterval;

    let recordedTrackBlob = null;
    let recordedTrackUrl = null;

    let precisionPlayer = null;

    // Arrangement controls functionality
    let isArrangementMenuOpen = false;

    // voice commands
    let voiceCommands = null;

    async function initPrecisionPlayer() {
        if (!precisionPlayer) {
            precisionPlayer = new PrecisionMIDIPlayer();
            await precisionPlayer.init();
            console.log("üéØ Precision MIDI player initialized");
        }
    }

    async function playStickyMidiPrecision() {
        const player = document.getElementById("stickyArrangementPlayer");
        if (!player || !player.src) {
            console.log("‚ùå No arrangement loaded");
            return;
        }

        try {
            // Try precision player first
            await initPrecisionPlayer();
            const success = await precisionPlayer.loadAndPlayWithDuration(
                player.src,
            );

            if (success) {
                console.log("üéØ Using precision playback");
                return;
            }
        } catch (error) {
            console.log(
                "‚ö†Ô∏è Precision player failed, falling back to html-midi-player",
            );
        }

        // Fallback to existing player
        player.start();
    }

    function stopStickyMidiPrecision() {
        // Stop precision player
        if (precisionPlayer) {
            precisionPlayer.stop();
        }

        // Also stop html-midi-player as fallback
        const player = document.getElementById("stickyArrangementPlayer");
        if (player) {
            player.stop();
            player.currentTime = 0;
        }
    }

    // Progressive enhancement - replace your existing functions
    function enhanceExistingMidiControls() {
        // Replace the playStickyMidi function
        window.playStickyMidi = playStickyMidiPrecision;
        window.stopStickyMidi = stopStickyMidiPrecision;

        // Add precision controls to your UI
        const stickyControls = document.querySelector(".sticky-midi-controls");
        if (stickyControls) {
            const precisionBtn = document.createElement("button");
            precisionBtn.className = "mini-midi-btn";
            precisionBtn.innerHTML = "üéØ";
            precisionBtn.title = "Precision Mode (9.6s)";
            precisionBtn.onclick = () => playStickyMidiPrecision();
            stickyControls.appendChild(precisionBtn);
        }
    }

    function autoConnect() {
        const deviceSelect = document.getElementById("deviceSelect");
        if (deviceSelect.value) {
            connectDevice(); // Your existing function
            updateMidiBarStatus("connected", "Connected");
        } else {
            updateMidiBarStatus("ready", "");
        }
    }

    function updateMidiBarStatus(type, message) {
        const statusDot = document.getElementById("midiStatusDot");
        const statusText = document.getElementById("midiStatusText");

        if (statusDot && statusText) {
            statusDot.classList.remove("connected");
            statusText.textContent = message;

            if (type === "connected") {
                statusDot.classList.add("connected");
            }
        }
    }

    // Toggle arrangement controls menu
    function toggleArrangementControls() {
        const menu = document.getElementById("arrangementControlsMenu");
        const toggle = document.querySelector(".arrangement-controls-toggle");

        isArrangementMenuOpen = !isArrangementMenuOpen;

        if (isArrangementMenuOpen) {
            menu.classList.add("show");
            toggle.classList.add("active");
        } else {
            menu.classList.remove("show");
            toggle.classList.remove("active");
        }
    }

    // Close arrangement menu when clicking outside
    document.addEventListener("click", function (event) {
        const container = document.querySelector(
            ".arrangement-controls-container",
        );
        if (!container.contains(event.target) && isArrangementMenuOpen) {
            toggleArrangementControls();
        }
    });

    // Toggle piano controls menu
    function togglePianoControls() {
        const menu = document.getElementById("pianoControlsMenu");
        const toggle = document.querySelector(".piano-controls-toggle");

        isPianoMenuOpen = !isPianoMenuOpen;

        if (isPianoMenuOpen) {
            menu.classList.add("show");
            toggle.classList.add("active");
        } else {
            menu.classList.remove("show");
            toggle.classList.remove("active");
        }
    }

    // Close piano menu when clicking outside
    document.addEventListener("click", function (event) {
        const container = document.querySelector(".piano-controls-container");
        if (!container.contains(event.target) && isPianoMenuOpen) {
            togglePianoControls();
        }
    });

    function updateMidiBarVolume(value) {
        document.getElementById("volumeValue").textContent = value + "%";
        // Connect to your existing pianoSynth
        if (pianoSynth && pianoSynth.setVolume) {
            pianoSynth.setVolume(value);
        }
    }

    function updateMidiBarSound(value) {
        // Connect to your existing pianoSynth
        if (pianoSynth && pianoSynth.setSoundType) {
            pianoSynth.setSoundType(value);
        }
    }

    // Visualizer Functions
    function retryVisualizerConnection() {
        updateVisualizerStatus("waiting", "Retrying connection...");
        spectrumInstance = null;

        setTimeout(() => {
            if (connectMidiToSpectrum()) {
            } else {
                updateVisualizerStatus(
                    "error",
                    "Manual retry failed - check console",
                );
            }
        }, 500);
    }

    function updateVisualizerStatus(status, message) {
        const statusDot = document.getElementById("audioStatusDot");
        const statusText = document.getElementById("audioStatusText");
        const retryBtn = document.getElementById("retryBtn");

        if (statusDot && statusText) {
            statusDot.classList.remove("connected", "active");

            switch (status) {
                case "connected":
                    statusDot.classList.add("connected");
                    if (retryBtn) retryBtn.style.display = "none";
                    break;
                case "active":
                    statusDot.classList.add("active");
                    if (retryBtn) retryBtn.style.display = "none";
                    break;
                case "error":
                    if (retryBtn) retryBtn.style.display = "inline-block";
                    break;
                case "waiting":
                default:
                    if (retryBtn) retryBtn.style.display = "none";
                    break;
            }

            statusText.textContent = message;
        }
    }

    function connectMidiToSpectrum() {
        if (!spectrumInstance) {
            const containers = document.querySelectorAll(
                ".circular-spectrum-container",
            );
            for (let i = 0; i < containers.length; i++) {
                const container = containers[i];
                if (container.spectrumInstance) {
                    spectrumInstance = container.spectrumInstance;
                    break;
                }
            }
        }

        if (!spectrumInstance || !pianoSynth || !pianoSynth.audioContext) {
            const missing = [];
            if (!spectrumInstance) missing.push("spectrumInstance");
            if (!pianoSynth) missing.push("pianoSynth");
            if (!pianoSynth?.audioContext) missing.push("audioContext");

            updateVisualizerStatus("waiting", `Missing: ${missing.join(", ")}`);
            return false;
        }

        try {
            const tapGain = pianoSynth.audioContext.createGain();
            tapGain.gain.value = 1.0;

            pianoSynth.masterGain.connect(tapGain);

            if (!spectrumInstance.audioContext) {
                spectrumInstance.audioContext = pianoSynth.audioContext;
            }

            if (!spectrumInstance.analyser) {
                spectrumInstance.analyser =
                    pianoSynth.audioContext.createAnalyser();
                spectrumInstance.analyser.fftSize = 512;
                spectrumInstance.analyser.smoothingTimeConstant = 0.8;
            }

            tapGain.connect(spectrumInstance.analyser);
            spectrumInstance.dataArray = new Uint8Array(
                spectrumInstance.analyser.frequencyBinCount,
            );
            spectrumInstance.isAudioActive = true;

            if (typeof spectrumInstance.setStatusActive === "function") {
                spectrumInstance.setStatusActive(true);
            }

            if (typeof spectrumInstance.updateStatus === "function") {
                spectrumInstance.updateStatus("MIDI Connected");
            }

            updateVisualizerStatus("connected", "MIDI audio connected");
            return true;
        } catch (error) {
            console.error("‚ùå Failed to connect MIDI to spectrum:", error);
            updateVisualizerStatus(
                "error",
                `Connection failed: ${error.message}`,
            );
            return false;
        }
    }

    function findSpectrumInstance(attempt = 1) {
        const containers = document.querySelectorAll(
            ".circular-spectrum-container",
        );

        for (let i = 0; i < containers.length; i++) {
            const container = containers[i];
            if (container.spectrumInstance) {
                spectrumInstance = container.spectrumInstance;
                updateVisualizerStatus(
                    "waiting",
                    "Spectrum ready - connect MIDI device",
                );
                return true;
            }
        }

        if (attempt < 5) {
            updateVisualizerStatus(
                "waiting",
                `Loading visualizer... (${attempt}/5)`,
            );
            setTimeout(() => findSpectrumInstance(attempt + 1), 1000);
        } else {
            updateVisualizerStatus(
                "error",
                "Visualizer failed to load - try refresh",
            );
        }

        return false;
    }

    async function connectDevice() {
        const deviceSelect = document.getElementById("deviceSelect");
        if (!deviceSelect) return;

        const deviceId = deviceSelect.value;

        if (
            !deviceId ||
            deviceId.includes("No MIDI") ||
            deviceId.includes("Error") ||
            deviceId.includes("Web MIDI")
        ) {
            updateStatus(
                "midiStatus",
                "Please select a valid MIDI device",
                "error",
            );
            updateMidiBarStatus("error", "Invalid device");
            return;
        }

        if (!midiAccess || !midiAccess.inputs) {
            setTimeout(() => connectDevice(), 200);
            return;
        }

        try {
            await pianoSynth.init();

            const input = Array.from(midiAccess.inputs.values()).find(
                (inp) => inp.id === deviceId,
            );

            if (!input) {
                updateStatus(
                    "midiStatus",
                    "Selected MIDI device not found",
                    "error",
                );
                updateMidiBarStatus("error", "Device not found");
                return;
            }

            input.onmidimessage = handleMIDIMessage;
            midiInput = input;

            updateStatus(
                "midiStatus",
                "üéπ Piano connected! Studio-quality audio enabled",
                "ready",
            );
            updateMidiBarStatus("connected", "Connected"); // NEW LINE FOR STICKY BAR

            const pianoControls = document.getElementById("pianoControls");
            if (pianoControls) {
                pianoControls.style.display = "block";
            }

            console.log("üéπ Connected to MIDI device:", input.name);

            // Connect to visualizer
            updateVisualizerStatus("waiting", "Connecting to visualizer...");

            setTimeout(() => {
                if (!connectMidiToSpectrum()) {
                    setTimeout(() => {
                        if (!connectMidiToSpectrum()) {
                            setTimeout(() => {
                                if (!connectMidiToSpectrum()) {
                                    updateVisualizerStatus(
                                        "error",
                                        "Visualizer connection failed - MIDI audio still works",
                                    );
                                }
                            }, 2000);
                        }
                    }, 1000);
                }
            }, 500);
        } catch (error) {
            console.error("Error connecting to MIDI device:", error);
            updateStatus(
                "midiStatus",
                "Failed to connect to MIDI device",
                "error",
            );
            updateMidiBarStatus("error", "Connection failed"); // NEW LINE FOR STICKY BAR
        }
    }

    // MIDI Recording Buffer - FRONTEND ONLY (No WebSockets!)

    // Fixed MidiRecorder class with proper state management
    class MidiRecorder {
        constructor() {
            this.isRecording = false;
            this.recordedNotes = [];
            this.startTime = null;
            this.recordingDuration = 0;
            this.silenceTimeout = null;
            this.mode = "time";
            this.wasCanceled = false;
            this.internalTimeout = null; // Track internal timeout
        }

        startRecording(mode = "time", duration = 10) {
            // CRITICAL: Clear all previous state first
            this.clearAllState();

            this.isRecording = true;
            this.recordedNotes = [];
            this.startTime = performance.now();
            this.mode = mode;
            this.recordingDuration = duration * 1000;
            this.wasCanceled = false;

            console.log(`üéπ MIDI Recording started (${mode} mode)`);

            if (mode === "time") {
                // Stop after fixed duration
                this.internalTimeout = setTimeout(() => {
                    if (this.isRecording) {
                        console.log("‚è∞ Internal timeout stopping recording");
                        this.stopRecording();
                    }
                }, this.recordingDuration);
            } else if (mode === "silence") {
                this.resetSilenceTimer();
            }
        }

        stopRecording() {
            if (!this.isRecording) return;

            this.isRecording = false;

            // Clear all timers
            this.clearAllTimers();

            const totalDuration = (performance.now() - this.startTime) / 1000;
            console.log(
                `üéπ MIDI Recording stopped - Duration: ${totalDuration.toFixed(1)}s, Notes: ${this.recordedNotes.length}`,
            );

            return this.recordedNotes;
        }

        cancelRecording() {
            if (!this.isRecording) {
                console.log("üõë No recording to cancel");
                return;
            }

            const totalDuration = (performance.now() - this.startTime) / 1000;
            const noteCount = this.recordedNotes.length;

            // Set cancellation flag BEFORE clearing state
            this.wasCanceled = true;
            this.isRecording = false;

            // Clear all timers and state
            this.clearAllTimers();
            this.clearAllState();

            console.log(
                `üõë MIDI Recording canceled - Duration: ${totalDuration.toFixed(1)}s, Notes discarded: ${noteCount}`,
            );

            return true;
        }

        clearAllTimers() {
            if (this.silenceTimeout) {
                clearTimeout(this.silenceTimeout);
                this.silenceTimeout = null;
            }

            if (this.internalTimeout) {
                clearTimeout(this.internalTimeout);
                this.internalTimeout = null;
            }
        }

        clearAllState() {
            this.recordedNotes = [];
            this.startTime = null;
            this.recordingDuration = 0;
            this.clearAllTimers();
        }

        addNote(note, velocity, timestamp, isNoteOn) {
            if (!this.isRecording) return;

            const relativeTime = (timestamp - this.startTime) / 1000;

            this.recordedNotes.push({
                note: note,
                velocity: velocity,
                time: relativeTime,
                isNoteOn: isNoteOn,
            });

            if (this.mode === "silence" && isNoteOn) {
                this.resetSilenceTimer();
            }
        }

        resetSilenceTimer() {
            if (this.silenceTimeout) {
                clearTimeout(this.silenceTimeout);
            }

            this.silenceTimeout = setTimeout(() => {
                if (this.isRecording) {
                    this.stopRecording();
                }
            }, 2000);
        }

        convertToMidiBlob() {
            if (this.recordedNotes.length === 0) {
                throw new Error("No notes recorded");
            }

            // Simple MIDI file creation
            const midiData = this.createMidiData(this.recordedNotes);
            return new Blob([midiData], { type: "audio/midi" });
        }

        createMidiData(notes) {
            // Very simplified MIDI file creation
            const header = new Uint8Array([
                0x4d,
                0x54,
                0x68,
                0x64, // "MThd"
                0x00,
                0x00,
                0x00,
                0x06, // Header length
                0x00,
                0x00, // Format 0
                0x00,
                0x01, // 1 track
                0x00,
                0x60, // 96 ticks per quarter note
            ]);

            const trackData = this.createTrackData(notes);
            const trackHeader = new Uint8Array([
                0x4d,
                0x54,
                0x72,
                0x6b, // "MTrk"
                ...this.int32ToBytes(trackData.length),
            ]);

            // Combine header + track header + track data
            const midiFile = new Uint8Array(
                header.length + trackHeader.length + trackData.length,
            );
            midiFile.set(header, 0);
            midiFile.set(trackHeader, header.length);
            midiFile.set(trackData, header.length + trackHeader.length);

            return midiFile;
        }

        createTrackData(notes) {
            const events = [];
            let currentTime = 0;

            // Sort notes by time
            const sortedNotes = [...notes].sort((a, b) => a.time - b.time);

            // Find the earliest note time to normalize against
            const firstNoteTime =
                sortedNotes.length > 0 ? sortedNotes[0].time : 0;

            // Normalize all note times so the first note starts at 0
            const normalizedNotes = sortedNotes.map((note) => ({
                ...note,
                time: note.time - firstNoteTime,
            }));

            for (const note of normalizedNotes) {
                const deltaTime = Math.max(
                    0,
                    Math.round((note.time - currentTime) * 160),
                ); // Convert to ticks at 100 BPM
                currentTime = note.time;

                // Add MIDI event
                const status = note.isNoteOn ? 0x90 : 0x80; // Note on/off on channel 1
                events.push(...this.variableLengthQuantity(deltaTime));
                events.push(status, note.note, note.velocity);
            }

            // End of track
            events.push(0x00, 0xff, 0x2f, 0x00);

            return new Uint8Array(events);
        }

        // üéØ NEW: Create MIDI specifically for user playback with proper padding
        createPlaybackMidiBlob() {
            if (this.recordedNotes.length === 0) {
                throw new Error("No notes recorded");
            }

            const midiData = this.createPlaybackMidiData(this.recordedNotes);
            return new Blob([midiData], { type: "audio/midi" });
        }

        createPlaybackMidiData(notes) {
            // Same header as original
            const header = new Uint8Array([
                0x4d,
                0x54,
                0x68,
                0x64, // "MThd"
                0x00,
                0x00,
                0x00,
                0x06, // Header length
                0x00,
                0x00, // Format 0
                0x00,
                0x01, // 1 track
                0x00,
                0x60, // 96 ticks per quarter note
            ]);

            const trackData = this.createPlaybackTrackData(notes);
            const trackHeader = new Uint8Array([
                0x4d,
                0x54,
                0x72,
                0x6b, // "MTrk"
                ...this.int32ToBytes(trackData.length),
            ]);

            const midiFile = new Uint8Array(
                header.length + trackHeader.length + trackData.length,
            );
            midiFile.set(header, 0);
            midiFile.set(trackHeader, header.length);
            midiFile.set(trackData, header.length + trackHeader.length);

            return midiFile;
        }

        createPlaybackTrackData(notes) {
            const events = [];
            let currentTime = 0;
            const targetDuration = 9.6;

            // Sort notes by time
            const sortedNotes = [...notes].sort((a, b) => a.time - b.time);
            const firstNoteTime =
                sortedNotes.length > 0 ? sortedNotes[0].time : 0;
            const normalizedNotes = sortedNotes.map((note) => ({
                ...note,
                time: note.time - firstNoteTime,
            }));

            // üéØ NEW APPROACH: Start with a sustain note that lasts the full duration
            // Add a very quiet sustain note at the beginning
            events.push(...this.variableLengthQuantity(0)); // Start immediately
            events.push(0x90, 127, 1); // Very quiet high note (out of way)

            // Add all user notes on top
            for (const note of normalizedNotes) {
                const deltaTime = Math.max(
                    0,
                    Math.round((note.time - currentTime) * 160),
                );
                currentTime = note.time;

                const status = note.isNoteOn ? 0x90 : 0x80;
                events.push(...this.variableLengthQuantity(deltaTime));
                events.push(status, note.note, note.velocity);
            }

            // End the sustain note at exactly 9.6 seconds
            const remainingTicks = Math.round(
                (targetDuration - currentTime) * 160,
            );
            events.push(...this.variableLengthQuantity(remainingTicks));
            events.push(0x80, 127, 0); // End sustain note at 9.6 seconds

            console.log(`üîç Sustain note holds for full ${targetDuration}s`);

            // End of track
            events.push(0x00, 0xff, 0x2f, 0x00);
            return new Uint8Array(events);
        }

        variableLengthQuantity(value) {
            const bytes = [];
            bytes.unshift(value & 0x7f);
            value >>= 7;
            while (value > 0) {
                bytes.unshift((value & 0x7f) | 0x80);
                value >>= 7;
            }
            return bytes;
        }

        int32ToBytes(value) {
            return [
                (value >> 24) & 0xff,
                (value >> 16) & 0xff,
                (value >> 8) & 0xff,
                value & 0xff,
            ];
        }
    }

    class PrecisionMIDIPlayer {
        constructor() {
            this.synth = null;
            this.forcedDuration = 9.6; // exactly 16 beats at 100 BPM
            this.isPlaying = false;
            this.currentMidiData = null;
            this.scheduledEvents = [];
        }

        async init() {
            if (!this.synth) {
                // Use your existing pianoSynth's audio context for consistency
                this.synth = new Tone.PolySynth().toDestination();

                // Connect to your existing visualizer if available
                if (pianoSynth && pianoSynth.audioContext) {
                    Tone.setContext(pianoSynth.audioContext);
                }
            }
        }

        async loadAndPlayWithDuration(midiUrl, forcedDuration = null) {
            await this.init();

            const duration = forcedDuration || this.forcedDuration;

            try {
                // Import @tonejs/midi dynamically (since it's not in your CDN)
                const { Midi } = await import(
                    "https://cdn.skypack.dev/@tonejs/midi"
                );

                const midi = await Midi.fromUrl(midiUrl);
                this.currentMidiData = midi;

                console.log(
                    `üéµ Loading MIDI with forced duration: ${duration}s`,
                );

                // Clear any existing scheduled events
                this.stop();

                // Schedule forced stop at exactly the specified duration
                const stopEvent = Tone.Transport.schedule(() => {
                    this.stop();
                    console.log(`‚è∞ Playback stopped at exactly ${duration}s`);
                }, duration);

                this.scheduledEvents.push(stopEvent);

                // Schedule all notes with duration checking
                midi.tracks.forEach((track) => {
                    track.notes.forEach((note) => {
                        if (note.time < duration) {
                            const adjustedDuration = Math.min(
                                note.duration,
                                duration - note.time,
                            );

                            const noteEvent = Tone.Transport.schedule(
                                (time) => {
                                    this.synth.triggerAttackRelease(
                                        note.name,
                                        adjustedDuration,
                                        time,
                                        note.velocity,
                                    );
                                },
                                note.time,
                            );

                            this.scheduledEvents.push(noteEvent);
                        }
                    });
                });

                // Start transport
                Tone.Transport.start();
                this.isPlaying = true;

                console.log(
                    `üéµ Precision playback started - will stop at ${duration}s`,
                );

                // Update your existing UI
                this.updatePlaybackStatus(true);

                return true;
            } catch (error) {
                console.error("‚ùå Precision MIDI playback failed:", error);
                return false;
            }
        }

        stop() {
            if (this.isPlaying) {
                Tone.Transport.stop();

                // Clear all scheduled events
                this.scheduledEvents.forEach((event) => {
                    Tone.Transport.clear(event);
                });
                this.scheduledEvents = [];

                this.isPlaying = false;
                this.updatePlaybackStatus(false);

                console.log("üõë Precision playback stopped");
            }
        }

        pause() {
            if (this.isPlaying) {
                Tone.Transport.pause();
                this.updatePlaybackStatus(false);
            }
        }

        resume() {
            if (!this.isPlaying && Tone.Transport.state === "paused") {
                Tone.Transport.start();
                this.updatePlaybackStatus(true);
            }
        }

        updatePlaybackStatus(playing) {
            // Update your existing UI elements
            const statusElements = document.querySelectorAll(
                ".midi-player-status",
            );
            statusElements.forEach((el) => {
                el.textContent = playing
                    ? "Playing (Precision Mode)"
                    : "Stopped";
            });
        }

        // Enhanced loop functionality with precise timing
        async playWithLoop(midiUrl, loopCount = -1) {
            let currentLoop = 0;

            const playLoop = async () => {
                if (loopCount !== -1 && currentLoop >= loopCount) {
                    console.log(
                        `üîÑ Loop sequence completed (${currentLoop} loops)`,
                    );
                    return;
                }

                await this.loadAndPlayWithDuration(midiUrl);
                currentLoop++;

                if (loopCount === -1 || currentLoop < loopCount) {
                    // Schedule next loop at exactly the right time
                    setTimeout(
                        () => {
                            if (this.isPlaying) {
                                // Only continue if not manually stopped
                                playLoop();
                            }
                        },
                        this.forcedDuration * 1000 + 50,
                    ); // 50ms gap between loops
                }
            };

            await playLoop();
        }
    }

    // Metronome Class using Web Audio API
    class Metronome {
        constructor() {
            this.isPlaying = false;
            this.bpm = 100;
            this.beatCount = 0;
            this.isCountingIn = false;
            this.countInBeat = 0;
            this.recordingStarted = false;
            this.audioContext = null;
            this.intervalId = null;
            this.nextNoteTime = 0;
            this.lookahead = 25.0;
            this.scheduleAheadTime = 0.1;
        }

        async initAudio() {
            if (!this.audioContext) {
                this.audioContext = new (window.AudioContext ||
                    window.webkitAudioContext)();

                if (this.audioContext.state === "suspended") {
                    await this.audioContext.resume();
                }
            }
        }

        playClick(time, isCountIn) {
            const osc = this.audioContext.createOscillator();
            const envelope = this.audioContext.createGain();

            osc.connect(envelope);
            envelope.connect(this.audioContext.destination);

            osc.frequency.value = isCountIn ? 800 : 400;

            envelope.gain.setValueAtTime(0, time);
            envelope.gain.linearRampToValueAtTime(0.3, time + 0.001);
            envelope.gain.exponentialRampToValueAtTime(0.001, time + 0.1);

            osc.start(time);
            osc.stop(time + 0.1);
        }

        nextNote() {
            const secondsPerBeat = 60.0 / this.bpm;
            this.nextNoteTime += secondsPerBeat;

            if (this.isCountingIn) {
                this.countInBeat++;
                this.updateVisualIndicator(this.countInBeat, true);

                if (this.countInBeat >= 4) {
                    this.isCountingIn = false;
                    this.beatCount = 0;
                    this.recordingStarted = true;
                    setTimeout(() => this.startMIDIRecording(), 50);
                }
            } else {
                this.beatCount++;
                this.updateVisualIndicator(this.beatCount, false);
            }
        }

        scheduleNote() {
            while (
                this.nextNoteTime <
                this.audioContext.currentTime + this.scheduleAheadTime
            ) {
                this.playClick(this.nextNoteTime, this.isCountingIn);
                this.nextNote();
            }
        }

        scheduler() {
            this.scheduleNote();

            if (this.isPlaying) {
                this.intervalId = setTimeout(
                    () => this.scheduler(),
                    this.lookahead,
                );
            }
        }

        async start(bpm, countIn = true) {
            try {
                await this.initAudio();

                this.bpm = bpm;
                this.beatCount = 0;
                this.countInBeat = 0;
                this.isCountingIn = countIn;
                this.recordingStarted = false;
                this.isPlaying = true;

                this.nextNoteTime = this.audioContext.currentTime;
                this.scheduler();
            } catch (error) {
                console.error("Error initializing metronome:", error);
                throw error;
            }
        }

        updateVisualIndicator(beat, isCountIn) {
            const beatCircle = document.getElementById("beatCircle");
            const beatCount = document.getElementById("beatCount");

            if (!beatCircle || !beatCount) return;

            beatCircle.classList.remove("active", "count-in");
            beatCount.classList.remove("count-in", "recording");

            if (isCountIn) {
                beatCircle.classList.add("count-in");
                beatCount.classList.add("count-in");
                beatCount.textContent = beat.toString();
            } else {
                beatCircle.classList.add("active");
                beatCount.classList.add("recording");
                beatCount.textContent = `Beat ${beat}`;
            }

            setTimeout(() => {
                beatCircle.classList.remove("active", "count-in");
            }, 150);
        }

        stop() {
            if (this.isPlaying) {
                this.isPlaying = false;
                this.isCountingIn = false;
                this.recordingStarted = false;

                if (this.intervalId) {
                    clearTimeout(this.intervalId);
                    this.intervalId = null;
                }

                // Reset beat indicator whenever metronome stops
                const beatCircle = document.getElementById("beatCircle");
                const beatCount = document.getElementById("beatCount");

                if (beatCircle && beatCount) {
                    beatCircle.classList.remove("active", "count-in");
                    beatCount.classList.remove("count-in", "recording");
                    beatCount.textContent = "";
                }

                console.log("ü•Å Metronome stopped");
            }
        }

        startMIDIRecording() {
            console.log("üéµ Starting MIDI recording after count-in...");

            // Calculate much longer buffer time to ensure we capture everything
            const currentTempo = 100; // Fixed tempo
            const beatsPerSecond = currentTempo / 60;
            const durationFor16Beats = 16 / beatsPerSecond;

            // Add 3 second buffer to absolutely ensure we don't cut off
            const bufferedDuration = durationFor16Beats + 3.0;

            console.log(
                `Recording: ${bufferedDuration.toFixed(1)}s (${durationFor16Beats.toFixed(1)}s + 3s buffer) for 16 beats at ${currentTempo} BPM`,
            );

            // Wait a tiny bit to ensure metronome timing is perfect
            setTimeout(() => {
                startDirectCapture(bufferedDuration);
            }, 50); // 50ms delay for perfect sync
        }
    }

    // Enhanced Piano Synthesizer Class - Controlled Reverb
    class PianoSynth {
        constructor() {
            this.audioContext = null;
            this.masterGain = null;
            this.dryGain = null;
            this.wetGain = null;
            this.reverbNode = null;
            this.activeNotes = new Map();
            this.volume = 0.1;
            this.reverbAmount = 0.15; // 15% reverb by default
            this.soundType = "piano";
        }

        async init() {
            if (!this.audioContext) {
                this.audioContext = new (window.AudioContext ||
                    window.webkitAudioContext)();

                // Create gain nodes for dry/wet mixing
                this.masterGain = this.audioContext.createGain();
                this.dryGain = this.audioContext.createGain();
                this.wetGain = this.audioContext.createGain();

                // Set initial volumes
                this.masterGain.gain.value = this.volume;
                this.updateReverbMix();

                // Create subtle reverb
                await this.createReverb();

                // Connect: dry signal bypasses reverb, wet signal goes through reverb
                this.dryGain.connect(this.masterGain);
                this.wetGain.connect(this.reverbNode);
                this.reverbNode.connect(this.masterGain);
                this.masterGain.connect(this.audioContext.destination);

                if (this.audioContext.state === "suspended") {
                    await this.audioContext.resume();
                }
            }
        }

        async createReverb() {
            // Create convolution reverb - MUCH more subtle
            this.reverbNode = this.audioContext.createConvolver();

            // Create shorter, more subtle impulse response
            const length = this.audioContext.sampleRate * 0.5; // Only 0.5 seconds
            const impulse = this.audioContext.createBuffer(
                2,
                length,
                this.audioContext.sampleRate,
            );

            for (let channel = 0; channel < 2; channel++) {
                const channelData = impulse.getChannelData(channel);
                for (let i = 0; i < length; i++) {
                    const decay = Math.pow(1 - i / length, 3); // Faster decay
                    channelData[i] = (Math.random() * 2 - 1) * decay * 0.03; // Much quieter
                }
            }

            this.reverbNode.buffer = impulse;
        }

        updateReverbMix() {
            if (this.dryGain && this.wetGain) {
                // Mix between dry and wet signal
                this.dryGain.gain.value = 1 - this.reverbAmount;
                this.wetGain.gain.value = this.reverbAmount;
            }
        }

        midiNoteToFrequency(midiNote) {
            return 440 * Math.pow(2, (midiNote - 69) / 12);
        }

        createEnhancedPianoSound(frequency, startTime, duration = 3.0) {
            // Create multiple oscillators for rich harmonics
            const fundamental = this.audioContext.createOscillator();
            const harmonic2 = this.audioContext.createOscillator();
            const harmonic3 = this.audioContext.createOscillator();
            const subharmonic = this.audioContext.createOscillator();

            // Create filters for each oscillator
            const filter1 = this.audioContext.createBiquadFilter();
            const filter2 = this.audioContext.createBiquadFilter();
            const filter3 = this.audioContext.createBiquadFilter();
            const subFilter = this.audioContext.createBiquadFilter();

            // Create gain nodes for mixing
            const fundamentalGain = this.audioContext.createGain();
            const harmonic2Gain = this.audioContext.createGain();
            const harmonic3Gain = this.audioContext.createGain();
            const subGain = this.audioContext.createGain();
            const masterEnvelope = this.audioContext.createGain();

            // Configure oscillators based on sound type
            switch (this.soundType) {
                case "piano":
                    fundamental.type = "triangle";
                    harmonic2.type = "sine";
                    harmonic3.type = "sawtooth";
                    subharmonic.type = "sine";

                    fundamental.frequency.value = frequency;
                    harmonic2.frequency.value = frequency * 2;
                    harmonic3.frequency.value = frequency * 3;
                    subharmonic.frequency.value = frequency * 0.5;

                    filter1.type = "lowpass";
                    filter1.frequency.value = 2500;
                    filter1.Q.value = 1;

                    filter2.type = "bandpass";
                    filter2.frequency.value = 1500;
                    filter2.Q.value = 2;

                    filter3.type = "highpass";
                    filter3.frequency.value = 500;
                    filter3.Q.value = 1;

                    subFilter.type = "lowpass";
                    subFilter.frequency.value = 200;
                    subFilter.Q.value = 1;

                    fundamentalGain.gain.value = 0.6;
                    harmonic2Gain.gain.value = 0.3;
                    harmonic3Gain.gain.value = 0.15;
                    subGain.gain.value = 0.4;
                    break;

                case "electric":
                    fundamental.type = "sawtooth";
                    harmonic2.type = "triangle";
                    harmonic3.type = "square";
                    subharmonic.type = "sine";

                    fundamental.frequency.value = frequency;
                    harmonic2.frequency.value = frequency * 2;
                    harmonic3.frequency.value = frequency * 4;
                    subharmonic.frequency.value = frequency * 0.5;

                    filter1.type = "lowpass";
                    filter1.frequency.value = 1800;
                    filter1.Q.value = 3;

                    fundamentalGain.gain.value = 0.7;
                    harmonic2Gain.gain.value = 0.4;
                    harmonic3Gain.gain.value = 0.2;
                    subGain.gain.value = 0.3;
                    break;

                case "organ":
                    fundamental.type = "sawtooth";
                    harmonic2.type = "square";
                    harmonic3.type = "triangle";
                    subharmonic.type = "square";

                    fundamental.frequency.value = frequency;
                    harmonic2.frequency.value = frequency * 2;
                    harmonic3.frequency.value = frequency * 3;
                    subharmonic.frequency.value = frequency;

                    filter1.type = "lowpass";
                    filter1.frequency.value = 3500;
                    filter1.Q.value = 0.5;

                    fundamentalGain.gain.value = 0.5;
                    harmonic2Gain.gain.value = 0.4;
                    harmonic3Gain.gain.value = 0.3;
                    subGain.gain.value = 0.6;
                    break;

                case "synth":
                    fundamental.type = "square";
                    harmonic2.type = "sawtooth";
                    harmonic3.type = "triangle";
                    subharmonic.type = "square";

                    fundamental.frequency.value = frequency;
                    harmonic2.frequency.value = frequency * 1.5;
                    harmonic3.frequency.value = frequency * 0.75;
                    subharmonic.frequency.value = frequency * 0.5;

                    filter1.type = "bandpass";
                    filter1.frequency.value = 1200;
                    filter1.Q.value = 8;

                    fundamentalGain.gain.value = 0.8;
                    harmonic2Gain.gain.value = 0.6;
                    harmonic3Gain.gain.value = 0.4;
                    subGain.gain.value = 0.5;
                    break;
            }

            // Connect the audio graph
            fundamental.connect(filter1);
            filter1.connect(fundamentalGain);

            harmonic2.connect(filter2);
            filter2.connect(harmonic2Gain);

            harmonic3.connect(filter3);
            filter3.connect(harmonic3Gain);

            subharmonic.connect(subFilter);
            subFilter.connect(subGain);

            // Connect to both dry and wet paths
            fundamentalGain.connect(masterEnvelope);
            harmonic2Gain.connect(masterEnvelope);
            harmonic3Gain.connect(masterEnvelope);
            subGain.connect(masterEnvelope);

            // Split signal to dry and wet paths
            masterEnvelope.connect(this.dryGain); // Dry signal (no reverb)
            masterEnvelope.connect(this.wetGain); // Wet signal (with reverb)

            // Create realistic ADSR envelope
            const attackTime = 0.005;
            const decayTime = 0.3;
            const sustainLevel = 0.4;
            const releaseTime = 1.2;

            masterEnvelope.gain.setValueAtTime(0, startTime);
            masterEnvelope.gain.linearRampToValueAtTime(
                0.9,
                startTime + attackTime,
            );
            masterEnvelope.gain.exponentialRampToValueAtTime(
                sustainLevel,
                startTime + attackTime + decayTime,
            );
            masterEnvelope.gain.exponentialRampToValueAtTime(
                0.001,
                startTime + duration,
            );

            // Start all oscillators
            fundamental.start(startTime);
            harmonic2.start(startTime);
            harmonic3.start(startTime);
            subharmonic.start(startTime);

            // Stop all oscillators
            fundamental.stop(startTime + duration);
            harmonic2.stop(startTime + duration);
            harmonic3.stop(startTime + duration);
            subharmonic.stop(startTime + duration);

            return {
                fundamental,
                harmonic2,
                harmonic3,
                subharmonic,
                masterEnvelope,
                filters: [filter1, filter2, filter3, subFilter],
            };
        }

        playNote(midiNote, velocity = 100) {
            if (!this.audioContext) return;

            const frequency = this.midiNoteToFrequency(midiNote);
            const startTime = this.audioContext.currentTime;
            const normalizedVelocity = Math.max(
                0.1,
                Math.min(1.0, velocity / 127),
            );

            const sound = this.createEnhancedPianoSound(
                frequency,
                startTime,
                4.0,
            );
            sound.masterEnvelope.gain.value *= normalizedVelocity;

            this.activeNotes.set(midiNote, sound);

            // console.log(
            //     `üéπ Playing note ${midiNote} (${frequency.toFixed(1)}Hz) at velocity ${velocity}`,
            // );
        }

        stopNote(midiNote) {
            if (this.activeNotes.has(midiNote)) {
                const sound = this.activeNotes.get(midiNote);
                const releaseTime = this.audioContext.currentTime;

                // Natural release envelope
                sound.masterEnvelope.gain.exponentialRampToValueAtTime(
                    0.001,
                    releaseTime + 0.8,
                );

                this.activeNotes.delete(midiNote);
                // console.log(`üéπ Stopping note ${midiNote}`);
            }
        }

        setVolume(volume) {
            this.volume = Math.max(0, Math.min(1, volume / 100));
            if (this.masterGain) {
                this.masterGain.gain.setTargetAtTime(
                    this.volume,
                    this.audioContext.currentTime,
                    0.1,
                );
            }
        }

        setReverbAmount(amount) {
            this.reverbAmount = Math.max(0, Math.min(1, amount / 100));
            this.updateReverbMix();
        }

        setSoundType(soundType) {
            this.soundType = soundType;
        }

        testSound() {
            // Play a nice chord progression
            this.playNote(60, 80); // C4
            setTimeout(() => this.playNote(64, 70), 150); // E4
            setTimeout(() => this.playNote(67, 70), 300); // G4
            setTimeout(() => this.playNote(72, 60), 450); // C5
        }
    }

    class VoiceCommands {
        constructor() {
            this.recognition = null;
            this.isListening = false;
            this.isWakeWordMode = true;
            this.activeSession = false;
            this.sessionTimeout = null;
            this.isSpeaking = false; // üÜï NEW: Flag to track when we're speaking
            this.setupSpeechRecognition();
        }

        setupSpeechRecognition() {
            if (
                "webkitSpeechRecognition" in window ||
                "SpeechRecognition" in window
            ) {
                const SpeechRecognition =
                    window.SpeechRecognition || window.webkitSpeechRecognition;
                this.recognition = new SpeechRecognition();
                this.recognition.continuous = true;
                this.recognition.interimResults = false;
                this.recognition.lang = "en-US";

                this.recognition.onresult = (event) => {
                    const command =
                        event.results[
                            event.results.length - 1
                        ][0].transcript.toLowerCase();
                    console.log("üé§ Heard:", command);
                    this.processCommand(command);
                };

                this.recognition.onend = () => {
                    console.log("üé§ Recognition ended, restarting...");
                    // Add delay and state check before restarting
                    setTimeout(() => {
                        if (this.isListening && !this.isSpeaking) {
                            try {
                                this.recognition.start();
                            } catch (error) {
                                console.log(
                                    "üé§ Restart failed:",
                                    error.message,
                                );
                                // Try again after longer delay
                                setTimeout(() => {
                                    if (this.isListening && !this.isSpeaking) {
                                        try {
                                            this.recognition.start();
                                        } catch (e) {
                                            console.log(
                                                "üé§ Second restart failed:",
                                                e.message,
                                            );
                                        }
                                    }
                                }, 2000);
                            }
                        }
                    }, 500);
                };

                this.recognition.onerror = (event) => {
                    console.log("üé§ Speech error:", event.error);
                    if (event.error !== "not-allowed") {
                        setTimeout(() => {
                            if (this.isListening && !this.isSpeaking) {
                                try {
                                    this.recognition.start();
                                } catch (error) {
                                    console.log(
                                        "üé§ Error restart failed:",
                                        error.message,
                                    );
                                }
                            }
                        }, 1000);
                    }
                };
            }
        }

        processCommand(command) {
            // üõ°Ô∏è IGNORE commands while we're speaking
            if (this.isSpeaking) {
                console.log("üîá Ignoring command - system is speaking");
                return;
            }

            if (this.isWakeWordMode && !this.activeSession) {
                // Wake word detection
                if (command.includes("hey wave") || command.includes("hey")) {
                    console.log("üëã Wake word detected!");

                    const responses = [
                        "What's up?",
                        "Yeah?",
                        "I'm listening",
                        "Go ahead",
                        "What can I do?",
                        "I'm here",
                        "Yes?",
                        "Ready!",
                        "What's on your mind?",
                        "How can I help?",
                    ];

                    const randomResponse =
                        responses[Math.floor(Math.random() * responses.length)];
                    this.speak(randomResponse);

                    this.isWakeWordMode = false;
                    this.startActiveSession();
                    return;
                }
            } else {
                // Command mode - execute actual commands
                if (command.includes("record")) {
                    console.log("‚ñ∂Ô∏è Starting recording...");
                    this.speak("Starting recording");
                    startCapture();
                    this.extendActiveSession();
                } else if (command.includes("cancel")) {
                    console.log("‚èπÔ∏è Cancelling recording...");
                    this.speak("Cancelling recording");
                    stopCapture();
                    this.extendActiveSession();
                } else if (command.includes("jam")) {
                    console.log("üéµ Playing...");
                    const playResponses = [
                        "Playing arrangement",
                        "Here we go!",
                        "Let's hear it",
                        "Starting playback",
                        "Playing now",
                    ];
                    const randomPlay =
                        playResponses[
                            Math.floor(Math.random() * playResponses.length)
                        ];
                    this.speak(randomPlay);
                    playStickyMidi();
                    this.extendActiveSession();
                } else if (command.includes("stop")) {
                    console.log("‚èπÔ∏è Stopping playback...");
                    const stopResponses = [
                        "Stopping playback",
                        "All stopped",
                        "Paused",
                        "Stopping now",
                        "Done",
                    ];
                    const randomStop =
                        stopResponses[
                            Math.floor(Math.random() * stopResponses.length)
                        ];
                    this.speak(randomStop);
                    stopStickyMidi();
                    this.extendActiveSession();
                } else if (command.includes("generate")) {
                    console.log("üéº Generating...");
                    this.speak("Generating arrangement");
                    analyzeAndGenerate();
                    this.extendActiveSession();
                } else if (command.includes("loop")) {
                    console.log("Looping...");
                    this.speak("Looping arrangement");
                    toggleStickyMidiLoop();
                    this.extendActiveSession();
                } else {
                    // ü§ñ NEW: If no local command matches, send to OpenAI
                    console.log(
                        "ü§ñ Unrecognized command, sending to OpenAI:",
                        command,
                    );
                    this.handleComplexCommand(command);
                }
            }
        }

        // Add this method to your VoiceCommands class////////////////////////////////////////////////////////
        async handleComplexCommand(command) {
            this.extendActiveSession();

            try {
                const apiKey = import.meta.env.PUBLIC_OPENAI_API_KEY;

                // Get current analysis results if available
                let contextMessage = "";

                if (window.uploadedMidiResult) {
                    const result = window.uploadedMidiResult;

                    if (result.detected_type === "chord_progression") {
                        const chords = result.chord_progression || [];
                        contextMessage = `Current analyzed chord progression: ${chords.join(" ‚Üí ")}. Key: ${result.key || "Unknown"}.`;
                    } else if (result.harmonizations) {
                        const style =
                            document.getElementById("stickyHarmonyStyle")
                                ?.value || "simple_pop";
                        const chords =
                            result.harmonizations[style]?.progression || [];
                        contextMessage = `Current melody harmonized as: ${chords.join(" ‚Üí ")}. Key: ${result.key || "Unknown"}.`;
                    }

                    if (result.key_confidence) {
                        contextMessage += ` (${(result.key_confidence * 100).toFixed(0)}% confidence)`;
                    }
                }

                // Determine if user has current analysis
                const hasCurrentAnalysis = !!window.uploadedMidiResult;

                const systemPrompt = hasCurrentAnalysis
                    ? `You‚Äôre a music co-pilot for songwriters and composers.
                    Your responses are part of a real-time creative flow, so keep replies under 30 words and focused. The user has already recorded and analyzed their music‚Äîyou can see their chord progression.

                    Your role:

                    React naturally: use short, supportive phrases like ‚Äúnice one,‚Äù ‚Äúlet‚Äôs build on that,‚Äù ‚Äúhere‚Äôs a thought,‚Äù or ‚Äúthis could be cool.‚Äù

                    Suggest specific next chords based on the current progression.

                    Offer harmonic variations, extensions, or substitutions‚Äîmusically grounded and in context.

                    Recommend arrangement ideas that build on what they‚Äôve already played.

                    Think like a producer: give actionable, concrete musical feedback.

                    Help break creative blocks with quick, specific musical suggestions.

                    Suggest melodic directions that fit and elevate their chords.

                    For lyrics: help guide thought process or structure, but don‚Äôt write full lyrics.

                    Keep things flowing‚Äîdon‚Äôt over-explain or interrupt creative momentum.

                    Stay in your lane: politely decline non-music questions.

                    Avoid:

                    Repeating suggestions to re-record‚Äîassume the music is already analyzed.

                    Abstract or overly vague advice‚Äîalways be musically useful.

                    Tone: Warm, grounded, musically intelligent, and creatively supportive. You're here to help them make confident next moves.`
                    : `You are a music co-pilot for songwriters and composers. Keep responses under 30 words since this is voice interaction.

            Your role:
            - Support through creative blocks by suggesting "reh-CORD" to capture their current musical ideas for analysis
            - For chord progressions: always suggest recording what they have so far to recommend the next chord
            - Arrange music around user ideas to help them hear fuller arrangements
            - Act as producer with suggestive feedback, not demanding direction
            - Stay intuitive and flow-friendly - don't over-talk or disrupt creativity
            - For musical ideas that can be played: suggest saying "reh-CORD" to capture and analyze their MIDI input
            - For lyrics: act as a thought-process guide, not a lyric generator - help calibrate their creative thinking
            - Politely decline non-music queries as outside your scope

            When users ask about chord progressions, always suggest they record their current chords first.
            Always use "reh-CORD" (phonetic spelling) instead of "record" for the verb.

            Tone: Supportive, suggestive, concise. You're an extra set of musically intelligent ears in their creative process.`;

                const messages = [
                    {
                        role: "system",
                        content: systemPrompt,
                    },
                ];

                // Add context about current analysis if available
                if (contextMessage) {
                    messages.push({
                        role: "system",
                        content: contextMessage,
                    });
                }

                // Add user command
                messages.push({
                    role: "user",
                    content: command,
                });

                const response = await fetch(
                    "https://api.openai.com/v1/chat/completions",
                    {
                        method: "POST",
                        headers: {
                            "Content-Type": "application/json",
                            Authorization: `Bearer ${apiKey}`,
                        },
                        body: JSON.stringify({
                            model: "gpt-3.5-turbo", // Always use this since no images
                            messages: messages,
                            max_tokens: 100,
                            temperature: 0.7,
                        }),
                    },
                );

                const result = await response.json();

                if (!response.ok) {
                    throw new Error(
                        `OpenAI API error: ${response.status} - ${result.error?.message || "Unknown error"}`,
                    );
                }

                const aiResponse = result.choices[0].message.content;

                this.speakLonger(aiResponse);
            } catch (error) {
                console.error("‚ùå OpenAI request failed:", error);
                this.speak("Sorry, I couldn't process that right now");
            }
        }

        // Add this helper method to the VoiceCommands class
        async getVisualizationAsBase64(filename) {
            try {
                const response = await fetch(
                    `/generated_visualizations/${filename}`,
                );
                if (!response.ok) {
                    throw new Error(
                        `Failed to fetch visualization: ${response.status}`,
                    );
                }

                const blob = await response.blob();
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = () => {
                        const base64 = reader.result.split(",")[1]; // Remove data:image/png;base64, prefix
                        resolve(base64);
                    };
                    reader.onerror = reject;
                    reader.readAsDataURL(blob);
                });
            } catch (error) {
                console.error(
                    "Error converting visualization to base64:",
                    error,
                );
                return null;
            }
        }

        // üÜï NEW: Longer speaking method for AI responses
        speakLonger(text) {
            if ("speechSynthesis" in window) {
                // STOP LISTENING while speaking to prevent feedback loop
                if (this.recognition) {
                    this.recognition.stop();
                }

                this.isSpeaking = true;
                console.log(
                    "üîá Speaking mode ON (AI response) - commands blocked",
                );

                const utterance = new SpeechSynthesisUtterance(text);

                // Same voice selection as your regular speak method
                const voices = speechSynthesis.getVoices();
                if (voices.length > 0) {
                    const selectedVoice = voices.find((voice) =>
                        voice.name.includes("Mark"),
                    );
                    if (selectedVoice) {
                        utterance.voice = selectedVoice;
                    }
                }

                utterance.rate = 0.9;
                utterance.volume = 0.7;

                utterance.onend = () => {
                    // üîß LONGER BUFFER for AI responses (3 seconds vs 1 second)
                    setTimeout(() => {
                        this.isSpeaking = false;
                        // RESTART LISTENING after speaking
                        if (this.isListening && this.recognition) {
                            this.recognition.start();
                        }
                        console.log(
                            "üé§ Speaking mode OFF - commands enabled (after AI response)",
                        );
                    }, 3000); // 3 second buffer instead of 1
                };

                utterance.onerror = () => {
                    setTimeout(() => {
                        this.isSpeaking = false;
                        // RESTART LISTENING after error
                        if (this.isListening && this.recognition) {
                            this.recognition.start();
                        }
                        console.log("üé§ Speaking mode OFF after error");
                    }, 3000);
                };

                speechSynthesis.speak(utterance);
                console.log("üó£Ô∏è Speaking AI response:", text);
            }
        }

        // üÜï NEW: Start active session (stays awake for commands)
        startActiveSession() {
            this.activeSession = true;
            this.isWakeWordMode = false;
            console.log("üî• Active session started - no wake word needed");

            // Set timeout to end session after 30 seconds of inactivity
            this.sessionTimeout = setTimeout(() => {
                this.endActiveSession();
            }, 30000); // 30 seconds
        }

        // üÜï NEW: Extend active session (reset the timeout)
        extendActiveSession() {
            if (this.activeSession) {
                // Clear existing timeout
                if (this.sessionTimeout) {
                    clearTimeout(this.sessionTimeout);
                }

                // Set new timeout
                this.sessionTimeout = setTimeout(() => {
                    this.endActiveSession();
                }, 30000); // Another 30 seconds

                console.log("‚è∞ Active session extended - 30 more seconds");
            }
        }

        // üÜï NEW: End active session (back to wake word mode)
        endActiveSession() {
            this.activeSession = false;
            this.isWakeWordMode = true;

            if (this.sessionTimeout) {
                clearTimeout(this.sessionTimeout);
                this.sessionTimeout = null;
            }

            console.log("üò¥ Session ended - say 'Hey Wave' to start again");
            this.speak("Session ended"); // Optional: notify user
        }

        // üÜï NEW: Simple flag-based speak method
        speak(text) {
            if ("speechSynthesis" in window) {
                // STOP LISTENING while speaking to prevent feedback loop
                if (this.recognition) {
                    this.recognition.stop();
                }

                this.isSpeaking = true; // üö´ Block commands while speaking
                console.log("üîá Speaking mode ON - commands blocked");

                const utterance = new SpeechSynthesisUtterance(text);

                utterance.voice = speechSynthesis
                    .getVoices()
                    .find((voice) => voice.name.includes("Mark"));

                utterance.rate = 0.9;
                utterance.volume = 0.7;

                utterance.onend = () => {
                    // Add delay before allowing commands again
                    setTimeout(() => {
                        this.isSpeaking = false; // ‚úÖ Allow commands again
                        // RESTART LISTENING after speaking
                        if (this.isListening && this.recognition) {
                            this.recognition.start();
                        }
                        console.log("üé§ Speaking mode OFF - commands enabled");
                    }, 1000); // 1 second buffer
                };

                utterance.onerror = () => {
                    setTimeout(() => {
                        this.isSpeaking = false;
                        // RESTART LISTENING after error
                        if (this.isListening && this.recognition) {
                            this.recognition.start();
                        }
                        console.log("üé§ Speaking mode OFF after error");
                    }, 1000);
                };

                speechSynthesis.speak(utterance);
                console.log("üó£Ô∏è Speaking:", text);
            }
        }

        startListening() {
            if (this.recognition && !this.isListening) {
                // Add !this.isListening check
                this.isListening = true;
                this.recognition.start();
                console.log('üëÇ Always listening for "Hey Wave"...');
            }
        }

        stopListening() {
            this.isListening = false;
            if (this.recognition) {
                this.recognition.stop();
            }
        }
    }

    // Initialize objects
    metronome = new Metronome();
    pianoSynth = new PianoSynth();
    midiRecorder = new MidiRecorder();

    // MIDI Player Functions
    function initializeMidiPlayer() {
        midiPlayer = document.getElementById("arrangementPlayer");
        if (midiPlayer) {
            console.log("üéµ MIDI Player initialized");
            // Set playbackRate to match desired BPM (100) from default (120)
            midiPlayer.playbackRate = baseBPM / defaultBPM;
            updateMidiDebugInfo(
                `Playback rate: ${midiPlayer.playbackRate.toFixed(3)} for BPM ${baseBPM}`,
            );
            updateMidiDebugInfo(
                `16-beat loop duration: ${getMidiLoopEnd().toFixed(2)}s`,
            );

            midiPlayer.addEventListener("start", () => {
                updateMidiDebugInfo("Playback started");
                if (isMidiLooping) {
                    if (midiCheckLoopInterval)
                        clearInterval(midiCheckLoopInterval);
                    midiCheckLoopInterval = setInterval(() => {
                        if (midiPlayer.currentTime !== undefined) {
                            const loopEnd = getMidiLoopEnd();
                            const loopStart = getMidiLoopStart();
                            // Trigger loop 200ms early to beat the stop
                            if (midiPlayer.currentTime >= loopEnd - 0.2) {
                                midiPlayer.currentTime = loopStart;
                                setTimeout(() => {
                                    if (!midiPlayer.playing) {
                                        midiPlayer.start();
                                        updateMidiDebugInfo(
                                            "Player restarted after loop",
                                        );
                                    }
                                }, 10); // Small delay to ensure time is set
                                updateMidiDebugInfo(
                                    `Loop: ${midiPlayer.currentTime.toFixed(2)}s -> ${loopStart.toFixed(2)}s`,
                                );
                            }
                        }
                    }, 5); // Check every 5ms for tighter control
                }
            });

            midiPlayer.addEventListener("stop", () => {
                updateMidiDebugInfo(
                    `Stopped at ${midiPlayer.currentTime?.toFixed(2) || "unknown"}s, Looping: ${isMidiLooping}`,
                );
                if (midiCheckLoopInterval) {
                    clearInterval(midiCheckLoopInterval);
                    midiCheckLoopInterval = null;
                }
            });
        } else {
            console.error("‚ùå No MIDI player found");
            updateMidiDebugInfo("ERROR: MIDI player not found");
        }
    }

    function getMidiLoopStart() {
        return 0; // Always start from beginning
    }

    function getMidiLoopEnd() {
        // Fixed 16-beat duration at 100 BPM
        return (beatsPerLoop * 60) / baseBPM; // 9.6s for 16 beats at 100 BPM
    }

    function updateMidiDebugInfo(message) {
        const info = document.getElementById("midiPlayerInfo");
        if (info) {
            const timestamp = new Date().toLocaleTimeString();
            info.innerHTML += `[${timestamp}] ${message}<br>`;
            info.scrollTop = info.scrollHeight;
        }
    }

    function toggleMidiPlay() {
        if (midiPlayer) {
            if (midiPlayer.playing) {
                midiPlayer.stop();
            } else {
                midiPlayer.start();
            }
        }
    }

    function stopMidi() {
        if (midiPlayer) {
            midiPlayer.stop();
            midiPlayer.currentTime = 0;
            updateMidiDebugInfo("Reset to start");
        }
    }

    function toggleMidiLoop() {
        isMidiLooping = !isMidiLooping;
        document.getElementById("midiLoopStatus").textContent =
            `Loop: ${isMidiLooping ? "ON" : "OFF"}`;
        updateMidiDebugInfo(`Looping: ${isMidiLooping ? "ON" : "OFF"}`);

        // Clear interval when looping is turned off
        if (!isMidiLooping && midiCheckLoopInterval) {
            clearInterval(midiCheckLoopInterval);
            midiCheckLoopInterval = null;
        }
    }

    // Completely robust showMidiPlayer function that eliminates ALL path issues
    function showMidiPlayer(arrangementFilename) {
        const midiPlayerSection = document.getElementById("midiPlayerSection");
        const midiPlayer = document.getElementById("arrangementPlayer");

        if (midiPlayerSection && midiPlayer) {
            // COMPLETELY strip everything and get just the filename
            let justFilename = arrangementFilename;

            console.log("üîß DEBUG: Original input:", justFilename);

            // Remove any URL protocols
            justFilename = justFilename.replace(/^https?:\/\/[^\/]+/, "");

            // Remove any leading slashes
            justFilename = justFilename.replace(/^\/+/, "");

            // If it contains ANY path separators, just get the last part (filename only)
            if (justFilename.includes("/")) {
                justFilename = justFilename.split("/").pop();
            }

            // If it contains backslashes (Windows paths), get the last part
            if (justFilename.includes("\\")) {
                justFilename = justFilename.split("\\").pop();
            }

            // Remove any remaining path prefixes
            justFilename = justFilename.replace(
                /.*generated_arrangements[\/\\]/,
                "",
            );

            // Final safety check - if it STILL has path separators, just get the last part
            while (justFilename.includes("/") || justFilename.includes("\\")) {
                justFilename = justFilename.split(/[\/\\]/).pop();
            }

            // Construct the clean path - ONLY use the filename
            const finalPath = `/generated_arrangements/${justFilename}`;

            console.log("üîß DEBUG: Extracted filename:", justFilename);
            console.log("üîß DEBUG: Final path:", finalPath);

            // Set the source
            midiPlayer.src = finalPath;

            // Show the player
            midiPlayerSection.style.display = "block";

            // Initialize player if not already done
            initializeMidiPlayer();

            updateMidiDebugInfo(`Loaded: ${justFilename}`);
            updateMidiDebugInfo(`Path: ${finalPath}`);
            console.log("üéµ MIDI Player loaded:", finalPath);

            // Test if the file actually exists by making a fetch request
            fetch(finalPath, { method: "HEAD" })
                .then((response) => {
                    if (response.ok) {
                        updateMidiDebugInfo(`‚úÖ File confirmed accessible`);
                    } else {
                        updateMidiDebugInfo(
                            `‚ùå File not found (${response.status})`,
                        );
                        console.error("File not accessible:", finalPath);
                    }
                })
                .catch((error) => {
                    updateMidiDebugInfo(
                        `‚ùå File check failed: ${error.message}`,
                    );
                    console.error("Error checking file:", error);
                });
        }
    }

    // Web MIDI API Functions
    async function loadDevices() {
        try {
            if (!navigator.requestMIDIAccess) {
                updateMidiBarStatus("error", "Not supported");

                const mainSelect = document.getElementById("deviceSelect");
                if (mainSelect) {
                    mainSelect.innerHTML =
                        "<option>Web MIDI not supported</option>";
                }
                return;
            }

            midiAccess = await navigator.requestMIDIAccess();
            const inputs = Array.from(midiAccess.inputs.values());

            const mainSelect = document.getElementById("deviceSelect");

            if (!mainSelect) return;

            mainSelect.innerHTML = "";

            if (inputs.length === 0) {
                mainSelect.innerHTML =
                    '<option value="">No MIDI devices found</option>';
                updateMidiBarStatus("waiting", "No devices");
            } else {
                // Add default option
                mainSelect.innerHTML =
                    '<option value="">Select MIDI Device...</option>';

                // Add all devices
                inputs.forEach((input, index) => {
                    const option = document.createElement("option");
                    option.value = input.id;
                    option.textContent = `${input.name}`;
                    mainSelect.appendChild(option);
                });

                updateMidiBarStatus("waiting", "Select device");

                // SIMPLE AUTO-CONNECT: Back to what was working
                if (inputs.length > 0) {
                    mainSelect.value = inputs[0].id;
                    console.log(
                        "üéπ Auto-connecting to first MIDI device:",
                        inputs[0].name,
                    );

                    // Single attempt with the original timing
                    setTimeout(() => {
                        connectDevice();
                    }, 1000);
                }
            }

            console.log("üéπ Found MIDI inputs:", inputs.length);
        } catch (error) {
            console.error("Error accessing MIDI:", error);
            updateMidiBarStatus("error", "Access failed");

            const mainSelect = document.getElementById("deviceSelect");
            if (mainSelect) {
                mainSelect.innerHTML = "<option>Error loading devices</option>";
            }
        }
    }

    function handleMIDIMessage(message) {
        const [command, note, velocity] = message.data;
        const timestamp = performance.now();

        // Note On (command 144-159, velocity > 0)
        if (command >= 144 && command <= 159 && velocity > 0) {
            // Play sound with perfect quality
            pianoSynth.playNote(note, velocity);

            // Record note if recording
            if (midiRecorder.isRecording) {
                midiRecorder.addNote(note, velocity, timestamp, true);
            }
        }
        // Note Off (command 128-143 or command 144-159 with velocity 0)
        else if (
            (command >= 128 && command <= 143) ||
            (command >= 144 && command <= 159 && velocity === 0)
        ) {
            // Stop sound naturally
            pianoSynth.stopNote(note);

            // Record note off if recording
            if (midiRecorder.isRecording) {
                midiRecorder.addNote(note, 0, timestamp, false);
            }
        }
    }

    // Fixed recording control functions
    function toggleRecording() {
        console.log(
            "üîÑ Toggle recording called, current state:",
            midiRecorder?.isRecording,
        );

        if (midiRecorder && midiRecorder.isRecording) {
            // Currently recording - cancel it
            console.log("üõë Canceling current recording");
            cancelRecording();
        } else {
            // Not recording - start it
            console.log("‚ñ∂Ô∏è Starting new recording");
            startCapture();
        }
    }

    function startCapture() {
        if (!midiInput) {
            updateStatus(
                "captureStatus",
                "Please connect a MIDI device first",
                "error",
            );
            return;
        }

        // Clear any cached analysis results FIRST
        clearPreviousAnalysis();

        const enableMetronome = true;
        const tempo = 100;

        // Update button to "stop" state IMMEDIATELY
        updateRecordingButton(true);

        if (enableMetronome) {
            updateStatus("captureStatus", "ü•Å Counting in...", "analyzing");

            try {
                metronome.start(tempo, true);
            } catch (error) {
                console.error("Error starting metronome:", error);
                updateStatus(
                    "captureStatus",
                    "Metronome error - starting recording without metronome",
                    "error",
                );
                startDirectCapture();
            }
        } else {
            startDirectCapture();
        }
    }

    function startDirectCapture(predefinedDuration = null) {
        console.log(
            "üé¨ Starting direct capture, predefined duration:",
            predefinedDuration,
        );

        const mode = "time";

        // **CRITICAL FIX: Use the buffered duration for both internal and external timeouts**
        const exactDurationFor16Bars = 10.6; // 16 beats at 100 BPM = 9.6s + 0.5s buffer

        let duration;
        if (predefinedDuration) {
            // Use the buffered duration instead of the exact calculated one
            duration = exactDurationFor16Bars;
        } else {
            duration = exactDurationFor16Bars;
        }

        console.log(`üéµ Recording for ${duration.toFixed(1)}s (mode: ${mode})`);

        // Start MIDI recording with the BUFFERED duration
        midiRecorder.startRecording(mode, duration);

        updateStatus(
            "captureStatus",
            "üéµ Recording... Play your melody!",
            "recording",
        );

        // Clear any existing auto-stop timeout
        if (window.currentAutoStopTimeout) {
            clearTimeout(window.currentAutoStopTimeout);
            window.currentAutoStopTimeout = null;
        }

        // Backup external timeout (should match the internal one now)
        const autoStopTimeout = setTimeout(() => {
            console.log("‚è∞ External auto-stop backup fired");
            stopCapture();
        }, exactDurationFor16Bars * 1000);

        window.currentAutoStopTimeout = autoStopTimeout;

        // Monitor recording status
        const statusInterval = setInterval(() => {
            if (!midiRecorder.isRecording) {
                console.log("üìä Recording finished, processing...");
                clearInterval(statusInterval);

                if (window.currentAutoStopTimeout) {
                    clearTimeout(window.currentAutoStopTimeout);
                    window.currentAutoStopTimeout = null;
                }

                processRecordingResults();
            } else {
                const notes = midiRecorder.recordedNotes;
                const elapsedTime =
                    (performance.now() - midiRecorder.startTime) / 1000;
                updateStatus(
                    "captureStatus",
                    `üéµ Recording... ${notes.length} events, ${elapsedTime.toFixed(1)}s`,
                    "recording",
                );
            }
        }, 100);
    }

    function processRecordingResults() {
        // Reset button FIRST
        updateRecordingButton(false);

        // CRITICAL: Stop metronome when recording finishes naturally
        if (metronome && metronome.isPlaying) {
            metronome.stop();
            console.log("ü•Å Metronome stopped after recording completion");
        }

        // Check cancellation flag
        if (midiRecorder.wasCanceled) {
            console.log("üõë Recording was canceled - no processing");
            updateStatus("captureStatus", "üõë Recording canceled", "ready");
            return;
        }

        // Normal completion - process the recording
        const notes = midiRecorder.recordedNotes;
        updateStatus(
            "captureStatus",
            `‚úÖ Recording finished! ${notes.length} MIDI events captured`,
            "ready",
        );

        // Auto-analyze if notes were captured
        if (notes.length > 0) {
            updateStatus(
                "captureStatus",
                "üì§ Uploading recorded MIDI for analysis...",
                "analyzing",
            );
            uploadRecordedMIDI();
        }
    }

    function cancelRecording() {
        console.log("üõë Canceling recording - no processing will occur");

        // Clear any external timeouts
        if (window.currentAutoStopTimeout) {
            clearTimeout(window.currentAutoStopTimeout);
            window.currentAutoStopTimeout = null;
            console.log("üõë Cleared auto-stop timeout (canceled)");
        }

        // Stop metronome
        if (metronome) {
            metronome.stop();
        }

        // Cancel MIDI recording
        if (midiRecorder.isRecording) {
            midiRecorder.cancelRecording();
        }

        // Clear cached analysis results
        clearPreviousAnalysis();

        // Reset UI elements
        resetRecordingUI();

        // Reset button
        updateRecordingButton(false);

        updateStatus("captureStatus", "üõë Recording canceled", "ready");
    }

    function updateRecordingButton(isRecording) {
        const button = document.getElementById("recordToggleBtn");
        if (button) {
            if (isRecording) {
                button.textContent = "üü•";
                button.className = "stop-btn";
            } else {
                button.textContent = "üéôÔ∏è";
                button.className = "record-btn";
            }
            console.log("üîÑ Button updated:", button.textContent);
        }
    }

    function clearPreviousAnalysis() {
        // Clear any cached results
        window.uploadedMidiResult = null;

        // Clear overlay
        const progressions = document.getElementById("progressions");
        if (progressions) {
            progressions.innerHTML = "";
        }

        console.log("üóëÔ∏è Cleared previous analysis results");

        // Hide recorded track player when starting new recording
        const recordedPlayer = document.getElementById("recordedTrackPlayer");
        if (recordedPlayer) {
            recordedPlayer.style.display = "none";
        }

        // Clean up recorded track URLs
        if (recordedTrackUrl) {
            URL.revokeObjectURL(recordedTrackUrl);
            recordedTrackUrl = null;
        }
        recordedTrackBlob = null;
    }

    function resetRecordingUI() {
        // Reset beat indicator
        const beatCircle = document.getElementById("beatCircle");
        const beatCount = document.getElementById("beatCount");
        if (beatCircle && beatCount) {
            beatCircle.classList.remove("active", "count-in");
            beatCount.classList.remove("count-in", "recording");
            // beatCount.textContent = "Ready";
        }
    }

    // Fixed metronome startMIDIRecording method
    function fixMetronomeStartMIDIRecording() {
        // Replace the existing startMIDIRecording method
        metronome.startMIDIRecording = function () {
            console.log("üéµ Starting MIDI recording after count-in...");

            const currentTempo = 100; // Fixed tempo
            const beatsPerSecond = currentTempo / 60;
            const durationFor16Beats = 16 / beatsPerSecond;

            // Use exact duration without extra buffer for timing precision
            const exactDuration = durationFor16Beats;

            console.log(
                `Recording: ${exactDuration.toFixed(1)}s for 16 beats at ${currentTempo} BPM`,
            );

            // Start recording with exact duration - no additional timeouts needed
            setTimeout(() => {
                startDirectCapture(exactDuration);
            }, 50);
        };
    }

    async function extendMidiFile(originalBlob) {
        try {
            const formData = new FormData();
            formData.append("file", originalBlob, "original.mid");

            const response = await fetch(`${API_BASE}/extend-midi`, {
                method: "POST",
                body: formData,
            });

            if (!response.ok)
                throw new Error(`Extension failed: ${response.status}`);

            return await response.blob();
        } catch (error) {
            console.error("‚ùå Failed to extend MIDI:", error);
            return originalBlob; // Fallback to original
        }
    }

    // Fixed stopCapture function
    function stopCapture() {
        console.log("üõë Stop capture called");

        // Clear any external timeouts
        if (window.currentAutoStopTimeout) {
            clearTimeout(window.currentAutoStopTimeout);
            window.currentAutoStopTimeout = null;
        }

        // Stop metronome
        if (metronome) {
            metronome.stop();
        }

        // Stop MIDI recording normally (not cancel)
        if (midiRecorder.isRecording) {
            midiRecorder.stopRecording();
        }

        updateStatus("captureStatus", "‚èπÔ∏è Recording stopped", "ready");
    }

    // Enhanced uploadRecordedMIDI with duration fix integration
    async function uploadRecordedMIDI() {
        try {
            if (
                !midiRecorder.recordedNotes ||
                midiRecorder.recordedNotes.length === 0
            ) {
                throw new Error("No recorded notes to upload");
            }

            if (midiRecorder.wasCanceled) {
                console.log("üõë Upload blocked - recording was canceled");
                return;
            }

            updateStatus(
                "captureStatus",
                "üîß Creating MIDI files...",
                "analyzing",
            );

            // üìä UNCHANGED: Create original MIDI for backend analysis (don't touch this!)
            const originalMidiBlob = midiRecorder.convertToMidiBlob();
            console.log("üìä Original MIDI created for backend analysis");

            // üéØ STEP 1: Send original MIDI to backend (unchanged path)
            updateStatus(
                "captureStatus",
                "üì§ Analyzing recorded MIDI...",
                "analyzing",
            );

            const analysisFormData = new FormData();
            analysisFormData.append(
                "file",
                originalMidiBlob,
                "recorded_melody_analysis.mid",
            );

            const response = await fetch(`${API_BASE}/analyze/melody`, {
                method: "POST",
                body: analysisFormData,
            });

            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(
                    `Analysis failed: ${response.status} - ${errorText}`,
                );
            }

            const result = await response.json();
            console.log("‚úÖ Backend analysis complete:", result);

            // üéµ STEP 2: Create tempo-fixed MIDI for playback (NEW separate path)
            updateStatus(
                "captureStatus",
                "üîß Fixing tempo for playback...",
                "analyzing",
            );

            const fixedMidiBlob = await fixMidiTempo(originalMidiBlob, 100);
            console.log("üéµ Tempo-fixed MIDI created for playback");

            // Use the tempo-fixed MIDI for frontend playback
            recordedTrackBlob = fixedMidiBlob;

            if (recordedTrackUrl) {
                URL.revokeObjectURL(recordedTrackUrl);
            }
            recordedTrackUrl = URL.createObjectURL(fixedMidiBlob);

            // Show the player
            showRecordedTrackPlayer();

            updateStatus(
                "captureStatus",
                "‚úÖ Analysis Complete! Playback ready at 100 BPM",
                "ready",
            );

            // Display results (unchanged)
            displayAutoAnalysisResults(result);
            window.uploadedMidiResult = result;

            console.log("üéØ SUCCESS:");
            console.log("  üìä Original MIDI: Sent to backend (unchanged)");
            console.log("  üéµ Fixed MIDI: Ready for playback (100 BPM)");
        } catch (error) {
            console.error("‚ùå Error in MIDI process:", error);
            updateStatus("captureStatus", `Failed: ${error.message}`, "error");
        }
    }

    // üéµ NEW: Fix MIDI tempo using @tonejs/midi (much simpler!)
    async function fixMidiTempo(midiBlob, targetBPM) {
        try {
            console.log(
                `üîß Fixing MIDI tempo to ${targetBPM} BPM using @tonejs/midi...`,
            );

            // Import Tone.js MIDI (dynamically)
            const { Midi } = await import(
                "https://cdn.skypack.dev/@tonejs/midi"
            );

            // Convert blob to array buffer
            const arrayBuffer = await midiBlob.arrayBuffer();

            // Parse the MIDI file
            const midi = new Midi(arrayBuffer);

            console.log(
                `üîç Original MIDI: ${midi.tracks.length} tracks, ${midi.durationTicks} ticks`,
            );
            console.log(`üîç Original tempo events:`, midi.header.tempos);

            // Clear existing tempo events and set new one
            midi.header.tempos = [];
            midi.header.setTempo(targetBPM, 0); // Set 100 BPM at time 0

            // Ensure the duration is exactly 9.6 seconds (16 beats at 100 BPM)
            const targetDuration = 9.6;
            console.log(
                `üîß Setting duration to exactly ${targetDuration} seconds`,
            );

            // Extend or trim all tracks to the target duration
            midi.tracks.forEach((track, index) => {
                console.log(`üîß Track ${index}: ${track.notes.length} notes`);

                // Add a silent note at the target duration to ensure length
                if (track.notes.length > 0) {
                    track.addNote({
                        midi: 127, // High note out of the way
                        time: targetDuration - 0.1, // Just before the end
                        duration: 0.1,
                        velocity: 1, // Very quiet
                    });
                }
            });

            // Convert back to MIDI blob
            const fixedMidiArray = midi.toArray();
            const fixedMidiBlob = new Blob([fixedMidiArray], {
                type: "audio/midi",
            });

            console.log(
                `‚úÖ MIDI tempo fixed: ${targetBPM} BPM, ${targetDuration}s duration`,
            );
            console.log(`üîç Fixed MIDI size: ${fixedMidiBlob.size} bytes`);

            return fixedMidiBlob;
        } catch (error) {
            console.error("‚ùå Tempo fix failed:", error);
            console.log("üîÑ Falling back to original MIDI");
            return midiBlob; // Return original if fixing fails
        }
    }

    // üß™ TEST: Add this function to test the tempo fix
    async function testTempoFix() {
        if (!recordedTrackBlob) {
            console.log("‚ùå No recorded track to test");
            return;
        }

        console.log("üß™ Testing tempo-fixed MIDI...");

        try {
            const { Midi } = await import(
                "https://cdn.skypack.dev/@tonejs/midi"
            );
            const arrayBuffer = await recordedTrackBlob.arrayBuffer();
            const midi = new Midi(arrayBuffer);

            console.log("üîç Test Results:");
            console.log(
                `   Duration: ${midi.duration.toFixed(2)}s (expected: 9.6s)`,
            );
            console.log(`   Tempo events:`, midi.header.tempos);
            console.log(
                `   First tempo:`,
                midi.header.tempos[0]?.bpm || "None",
            );

            if (
                midi.header.tempos.length > 0 &&
                Math.abs(midi.header.tempos[0].bpm - 100) < 1
            ) {
                console.log("‚úÖ Tempo fix SUCCESS!");
            } else {
                console.log("‚ùå Tempo fix FAILED");
            }
        } catch (error) {
            console.error("‚ùå Test failed:", error);
        }
    }

    // üéØ NEW: Test function to verify duration fix is working
    async function testDurationFix() {
        const player = document.getElementById("recordedTrackMidiPlayer");
        if (player && player.src) {
            console.log("üß™ Testing duration fix...");

            player.addEventListener("stop", function testListener() {
                const duration = player.currentTime || 0;
                console.log(
                    `üß™ Test result: Player stopped at ${duration.toFixed(2)}s`,
                );

                if (Math.abs(duration - 9.6) < 0.1) {
                    console.log("‚úÖ Duration fix successful!");
                    updateStatus(
                        "captureStatus",
                        "‚úÖ Duration fix verified: 9.6s",
                        "ready",
                    );
                } else {
                    console.log(
                        `‚ùå Duration fix failed: expected 9.6s, got ${duration.toFixed(2)}s`,
                    );
                    updateStatus(
                        "captureStatus",
                        `‚ùå Duration fix failed: ${duration.toFixed(2)}s`,
                        "error",
                    );
                }

                // Remove this test listener
                player.removeEventListener("stop", testListener);
            });

            // Start and let it play to completion
            player.start();
            updateStatus(
                "captureStatus",
                "üß™ Testing 9.6s duration...",
                "analyzing",
            );
        } else {
            console.log("‚ùå No recorded track to test");
        }
    }

    // üéØ NEW: Add test button to your recorded track controls
    function addDurationTestButton() {
        const recordedControls = document.querySelector(
            ".recorded-track-controls",
        );
        if (recordedControls) {
            const testBtn = document.createElement("button");
            testBtn.className = "mini-midi-btn";
            testBtn.innerHTML = "üß™";
            testBtn.title = "Test 9.6s Duration";
            testBtn.onclick = testDurationFix;
            recordedControls.appendChild(testBtn);
            console.log("üß™ Duration test button added");
        }
    }

    function simplifyChordProgression(chords) {
        // Check if we have an even number of chords
        if (chords.length % 2 !== 0) {
            return chords; // Can't be all pairs if odd number
        }

        // Check if all consecutive pairs are the same
        let allPairs = true;
        for (let i = 0; i < chords.length; i += 2) {
            if (chords[i] !== chords[i + 1]) {
                allPairs = false;
                break;
            }
        }

        // If all pairs, return simplified version
        if (allPairs) {
            const simplified = [];
            for (let i = 0; i < chords.length; i += 2) {
                simplified.push(chords[i]);
            }
            console.log(
                "üéµ Simplified doubled progression:",
                chords.join(" ‚Üí "),
                "to:",
                simplified.join(" ‚Üí "),
            );
            return simplified;
        }

        return chords; // Return original if not all pairs
    }

    // Fixed auto analysis display with proper fresh result handling
    function displayAutoAnalysisResults(result) {
        const progressions = document.getElementById("progressions");
        if (!progressions) return;

        // Verify we have a valid result
        if (!result) {
            console.log("‚ö†Ô∏è No result to display");
            return;
        }

        const detectedType = result.detected_type || "unknown";
        console.log("üéº Displaying analysis results for type:", detectedType);

        let chords = [];

        if (detectedType === "chord_progression") {
            chords = result.chord_progression || ["C", "F", "G", "C"];
        } else {
            if (result.harmonizations && result.harmonizations.simple_pop) {
                chords = result.harmonizations.simple_pop.progression || [
                    "C",
                    "F",
                    "G",
                    "C",
                ];
            } else {
                chords = ["C", "F", "G", "C"];
            }
        }

        const simplifiedChords = simplifyChordProgression(chords);

        // Display the chord progression
        if (simplifiedChords && simplifiedChords.length > 0) {
            progressions.innerHTML = simplifiedChords.join(" ‚Üí ");
            console.log(
                "‚úÖ Progression displayed:",
                simplifiedChords.join(" ‚Üí "),
            );
        } else {
            console.log("‚ö†Ô∏è No valid chords to display");
        }
    }

    // Fixed analyzeAndGenerate - handles both chord progression and melody results
    async function analyzeAndGenerate() {
        if (!window.uploadedMidiResult) {
            updateStatus(
                "captureStatus",
                "Please record a melody first",
                "error",
            );
            return;
        }

        // Get values from sticky bar (fallback to main form if sticky bar elements don't exist)
        const harmonySelect =
            document.getElementById("stickyHarmonyStyle") ||
            document.getElementById("harmonyStyle");
        const bassSlider =
            document.getElementById("stickyBassComplexity") ||
            document.getElementById("bassComplexity");
        const drumSlider =
            document.getElementById("stickyDrumComplexity") ||
            document.getElementById("drumComplexity");

        if (!harmonySelect || !bassSlider || !drumSlider) return;

        const style = harmonySelect.value;
        const bassComplexity = parseInt(bassSlider.value);
        const drumComplexity = parseInt(drumSlider.value);

        // Disable generate button during processing
        const generateBtn = document.getElementById("stickyGenerateBtn");
        if (generateBtn) {
            generateBtn.disabled = true;
            generateBtn.textContent = "üéµ Generating...";
        }

        updateStatus(
            "captureStatus",
            "üéµ Generating full arrangement...",
            "analyzing",
        );

        try {
            const result = window.uploadedMidiResult;
            const detectedType = result.detected_type || "melody";

            console.log(
                "üîß DEBUG: Detected type for arrangement:",
                detectedType,
            );
            console.log("üîß DEBUG: Full result object:", result);

            let selectedProgression;
            let styleMap = {};

            if (detectedType === "chord_progression") {
                // CHORD PROGRESSION PATH - Use the detected progression
                console.log(
                    "üéº Using detected chord progression for arrangement",
                );
                selectedProgression = result.chord_progression || [
                    "C",
                    "F",
                    "G",
                    "C",
                    "Am",
                    "F",
                    "G",
                    "C",
                ];

                // For chord progressions, all "styles" use the same detected progression
                styleMap = {
                    simple_pop: selectedProgression,
                    folk_acoustic: selectedProgression,
                    bass_foundation: selectedProgression,
                    phrase_foundation: selectedProgression,
                };

                console.log("üîß Using chord progression:", selectedProgression);
            } else {
                // MELODY PATH - Use harmonizations as before
                console.log("üéº Using melody harmonizations for arrangement");

                if (!result.harmonizations) {
                    throw new Error("No harmonizations found in melody result");
                }

                styleMap = {
                    simple_pop: result.harmonizations.simple_pop
                        ?.progression || [
                        "C",
                        "F",
                        "G",
                        "C",
                        "Am",
                        "F",
                        "G",
                        "C",
                    ],
                    folk_acoustic: result.harmonizations.folk_acoustic
                        ?.progression || [
                        "C",
                        "F",
                        "G",
                        "C",
                        "Am",
                        "F",
                        "G",
                        "C",
                    ],
                    bass_foundation: result.harmonizations.bass_foundation
                        ?.progression || [
                        "C",
                        "F",
                        "G",
                        "C",
                        "Am",
                        "F",
                        "G",
                        "C",
                    ],
                    phrase_foundation: result.harmonizations.phrase_foundation
                        ?.progression || [
                        "C",
                        "F",
                        "G",
                        "C",
                        "Am",
                        "F",
                        "G",
                        "C",
                    ],
                };

                selectedProgression = styleMap[style];
                console.log("üîß Selected harmonization style:", style);
            }

            console.log(
                "üîß Sending request with progression:",
                selectedProgression,
            );

            // Generate arrangement from the chord progression
            const response = await fetch(`${API_BASE}/generate/arrangement`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                    chord_progression: selectedProgression,
                    bpm: 100,
                    bass_complexity: bassComplexity,
                    drum_complexity: drumComplexity,
                    hi_hat_divisions: 2,
                    snare_beats: [2, 4],
                }),
            });

            if (!response.ok) {
                const errorText = await response.text();
                console.error("Backend error response:", errorText);
                throw new Error(
                    `Server error: ${response.status} - ${errorText}`,
                );
            }

            const arrangementResult = await response.json();

            console.log(
                "üîß Backend response full object:",
                JSON.stringify(arrangementResult, null, 2),
            );
            console.log(
                "üîß Backend output_file field:",
                arrangementResult.output_file,
            );

            if (arrangementResult.output_file) {
                // Pass the raw filename to showMidiPlayer - it will handle all cleaning
                showMidiPlayer(arrangementResult.output_file);

                // ADD THIS LINE - Show it in the sticky bar too
                showStickyMidiPlayer(arrangementResult.output_file);

                // Create result object for display (handle both types)
                let keyConfidence = 0.75; // Default confidence

                if (detectedType === "melody" && result.harmonizations) {
                    // Calculate confidence from harmonizations
                    const confidences = Object.values(result.harmonizations)
                        .map((h) => h?.confidence || 0)
                        .filter((c) => c > 0);
                    keyConfidence =
                        confidences.length > 0
                            ? Math.max(...confidences) / 100
                            : 0.75;
                }

                const fullResult = {
                    success: true,
                    key: result.key || "C",
                    key_confidence: keyConfidence,
                    chord_progressions: styleMap,
                    arrangement_file: arrangementResult.output_file
                        .split("/")
                        .pop(), // Just filename for download link
                    visualization_file: null,
                    visualization_url: null,
                    detected_type: detectedType,
                    analysis_path: result.analysis_path || detectedType,
                };

                updateStatus(
                    "analysisStatus",
                    "‚úÖ Analysis and arrangement complete!",
                    "ready",
                );
                displayFullResults(fullResult);
            } else {
                console.error("No output_file in response:", arrangementResult);
                updateStatus(
                    "analysisStatus",
                    `‚ùå ${arrangementResult.message || "No arrangement file returned"}`,
                    "error",
                );
            }
        } catch (error) {
            console.error("Error in analyzeAndGenerate:", error);
            updateStatus(
                "analysisStatus",
                `Analysis error: ${error.message}`,
                "error",
            );
        }
    }

    // Show sticky MIDI player
    function showStickyMidiPlayer(arrangementFilename) {
        const stickyPlayer = document.getElementById("stickyMidiPlayer");
        const stickyMidiElement = document.getElementById(
            "stickyArrangementPlayer",
        );
        const generateBtn = document.getElementById("stickyGenerateBtn");

        if (stickyPlayer && stickyMidiElement) {
            // Clean filename (same logic as your existing showMidiPlayer)
            let justFilename = arrangementFilename;
            justFilename = justFilename.replace(/^https?:\/\/[^\/]+/, "");
            justFilename = justFilename.replace(/^\/+/, "");
            if (justFilename.includes("/")) {
                justFilename = justFilename.split("/").pop();
            }
            if (justFilename.includes("\\")) {
                justFilename = justFilename.split("\\").pop();
            }
            justFilename = justFilename.replace(
                /.*generated_arrangements[\/\\]/,
                "",
            );
            while (justFilename.includes("/") || justFilename.includes("\\")) {
                justFilename = justFilename.split(/[\/\\]/).pop();
            }

            const finalPath = `/generated_arrangements/${justFilename}`;

            // Set source and show player
            stickyMidiElement.src = finalPath;
            stickyPlayer.style.display = "flex";

            console.log("üéµ Sticky MIDI Player loaded:", finalPath);
        }

        // Re-enable generate button
        if (generateBtn) {
            generateBtn.disabled = false;
            generateBtn.textContent = "üéµ Generate";
        }
    }

    function playStickyMidi() {
        const player = document.getElementById("stickyArrangementPlayer");
        if (player && player.src) {
            player.start(); // html-midi-player uses .start() method
            console.log("üéµ Started playing arrangement");
        } else {
            console.log("‚ùå No arrangement loaded to play");
            if (voiceCommands) {
                voiceCommands.speak("No arrangement available to play");
            }
        }
    }

    function stopStickyMidi() {
        const player = document.getElementById("stickyArrangementPlayer");
        if (player) {
            player.stop();
            player.currentTime = 0;
        }
    }

    function toggleStickyMidiLoop() {
        const player = document.getElementById("stickyArrangementPlayer");
        if (player) {
            player.loop = !player.loop;
            // Update button text or add visual indicator if needed
            console.log("Sticky player loop:", player.loop ? "ON" : "OFF");
        }
    }

    function downloadCurrentMidi() {
        const player = document.getElementById("stickyArrangementPlayer");
        if (player && player.src) {
            const filename = player.src.split("/").pop();
            const link = document.createElement("a");
            link.href = player.src;
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            console.log("üéµ Downloading:", filename);
        } else {
            console.log("‚ùå No MIDI file loaded to download");
        }
    }

    // Display Functions
    function displayFullResults(result) {
        const resultsSection = document.getElementById("results");
        const keyInfo = document.getElementById("keyInfo");
        const progressions = document.getElementById("progressions");
        const arrangementLink = document.getElementById("arrangementLink");
        const visualizationLink = document.getElementById("visualizationLink");

        if (
            !resultsSection ||
            !keyInfo ||
            !progressions ||
            !arrangementLink ||
            !visualizationLink
        )
            return;

        resultsSection.style.display = "block";

        keyInfo.innerHTML = `<strong>Detected Key:</strong> ${result.key} (confidence: ${result.key_confidence.toFixed(2)})`;

        let progressionsHtml = "<h4>Chord Progressions:</h4>";
        Object.entries(result.chord_progressions).forEach(([style, chords]) => {
            progressionsHtml += `<div>
                <strong>${style}:</strong> 
                <div class="chord-progression">${chords.join(" ‚Üí ")}</div>
            </div>`;
        });
        progressions.innerHTML = progressionsHtml;

        if (result.arrangement_file) {
            arrangementLink.innerHTML = `<strong>Generated Arrangement:</strong> <a href="/generated_arrangements/${result.arrangement_file}" download>üì• Download MIDI (${result.arrangement_file})</a>`;
        } else {
            arrangementLink.innerHTML =
                "<em>No arrangement file generated</em>";
        }

        if (result.visualization_file) {
            visualizationLink.innerHTML = `<strong>Visualization:</strong> <a href="${API_BASE}${result.visualization_url}" target="_blank" rel="noopener">üìä View Chord Progression Chart</a>`;
        } else {
            visualizationLink.innerHTML = "";
        }
    }

    // Utility Functions
    function updateStatus(elementId, message, type) {
        const element = document.getElementById(elementId);
        if (!element) return;

        element.textContent = message;
        element.className = `status ${type}`;
    }

    // Initialize everything
    document.addEventListener("DOMContentLoaded", function () {
        console.log("üöÄ DOM loaded, initializing...");

        // Initialize objects
        pianoSynth = new PianoSynth();
        midiRecorder = new MidiRecorder();

        // Start spectrum detection
        setTimeout(() => findSpectrumInstance(), 1000);

        // Load MIDI devices
        loadDevices();

        // Setup event listeners for sliders
        const bassComplexity = document.getElementById("bassComplexity");
        const drumComplexity = document.getElementById("drumComplexity");
        const bassValue = document.getElementById("bassValue");
        const drumValue = document.getElementById("drumValue");

        if (bassComplexity && bassValue) {
            bassComplexity.addEventListener("input", function (e) {
                bassValue.textContent = e.target.value;
            });
        }

        if (drumComplexity && drumValue) {
            drumComplexity.addEventListener("input", function (e) {
                drumValue.textContent = e.target.value;
            });
        }

        // Update slider values
        const stickyBassComplexity = document.getElementById(
            "stickyBassComplexity",
        );
        const stickyDrumComplexity = document.getElementById(
            "stickyDrumComplexity",
        );
        const stickyBassValue = document.getElementById("stickyBassValue");
        const stickyDrumValue = document.getElementById("stickyDrumValue");

        if (stickyBassComplexity && stickyBassValue) {
            stickyBassComplexity.addEventListener("input", function (e) {
                stickyBassValue.textContent = e.target.value;
            });
        }

        if (stickyDrumComplexity && stickyDrumValue) {
            stickyDrumComplexity.addEventListener("input", function (e) {
                stickyDrumValue.textContent = e.target.value;
            });
        }

        // Piano controls
        const pianoVolume = document.getElementById("pianoVolume");
        const pianoSound = document.getElementById("pianoSound");
        const volumeValue = document.getElementById("volumeValue");

        if (pianoVolume && volumeValue) {
            pianoVolume.addEventListener("input", function (e) {
                const volume = parseInt(e.target.value);
                volumeValue.textContent = volume + "%";
                pianoSynth.setVolume(volume);
            });
        }

        if (pianoSound) {
            pianoSound.addEventListener("change", function (e) {
                pianoSynth.setSoundType(e.target.value);
            });
        }

        // At the end of your existing DOMContentLoaded function, add:
        setTimeout(() => {
            if (metronome) {
                fixMetronomeStartMIDIRecording();
                console.log("üîß Metronome startMIDIRecording method fixed");
            }
        }, 1000);

        // Initialize voice commands and precision MIDI controls
        setTimeout(() => {
            voiceCommands = new VoiceCommands();

            // üé≠ LOAD VOICES EARLY:
            speechSynthesis.getVoices(); // Trigger voice loading

            voiceCommands.startListening();
            console.log(
                'üé§ Voice commands initialized - say "Hey Wave" to activate',
            );

            // üéØ ADD PRECISION MIDI ENHANCEMENT HERE
            enhanceExistingMidiControls();
            console.log("üéØ Precision MIDI controls enhanced");
        }, 2000);
    });

    // üéØ Add test button when recorded track player is shown
    function showRecordedTrackPlayer() {
        const recordedPlayer = document.getElementById("recordedTrackPlayer");
        const recordedMidiElement = document.getElementById(
            "recordedTrackMidiPlayer",
        );

        if (recordedPlayer && recordedMidiElement && recordedTrackUrl) {
            recordedMidiElement.src = recordedTrackUrl;

            // üéØ FIX: Set playback rate to match 100 BPM (from default 120 BPM)
            recordedMidiElement.playbackRate = baseBPM / defaultBPM; // 100/120 = 0.833

            recordedPlayer.style.display = "flex";
            console.log(
                `üéµ Recorded track player loaded with fixed duration at ${baseBPM} BPM (rate: ${recordedMidiElement.playbackRate.toFixed(3)})`,
            );

            // Add test button if not already present
            setTimeout(() => {
                if (
                    !document.querySelector(
                        '.recorded-track-controls .mini-midi-btn[title="Test 9.6s Duration"]',
                    )
                ) {
                    addDurationTestButton();
                }
            }, 100);
        }
    }

    function playRecordedTrack() {
        const player = document.getElementById("recordedTrackMidiPlayer");
        if (player && player.src) {
            player.start();
            console.log("üéµ Started playing recorded track");
        } else {
            console.log("‚ùå No recorded track to play");
        }
    }

    function stopRecordedTrack() {
        const player = document.getElementById("recordedTrackMidiPlayer");
        if (player) {
            player.stop();
            player.currentTime = 0;
            console.log("‚èπÔ∏è Stopped recorded track");
        }
    }

    function toggleRecordedTrackLoop() {
        const player = document.getElementById("recordedTrackMidiPlayer");
        if (player) {
            player.loop = !player.loop;
            console.log("Recorded track loop:", player.loop ? "ON" : "OFF");
        }
    }

    function saveRecordedTrack() {
        if (recordedTrackBlob) {
            const link = document.createElement("a");
            link.href = recordedTrackUrl;
            link.download = `recorded_track_${new Date().toISOString().slice(0, 19).replace(/:/g, "-")}.mid`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            console.log("üéµ Downloading recorded track");
        } else {
            console.log("‚ùå No recorded track to save");
        }
    }

    // Make functions globally accessible
    window.connectDevice = connectDevice;
    window.loadDevices = loadDevices;
    window.startCapture = startCapture;
    window.stopCapture = stopCapture;
    window.analyzeAndGenerate = analyzeAndGenerate;
    window.toggleMidiPlay = toggleMidiPlay;
    window.stopMidi = stopMidi;
    window.toggleMidiLoop = toggleMidiLoop;
    window.retryVisualizerConnection = retryVisualizerConnection;
    window.togglePianoControls = togglePianoControls;
    window.toggleArrangementControls = toggleArrangementControls;
    window.autoConnect = autoConnect;
    window.updateMidiBarVolume = updateMidiBarVolume;
    window.updateMidiBarSound = updateMidiBarSound;
    window.updateMidiBarStatus = updateMidiBarStatus;
    window.cancelRecording = cancelRecording;
    window.toggleRecording = toggleRecording;
    window.stopStickyMidi = stopStickyMidi;
    window.toggleStickyMidiLoop = toggleStickyMidiLoop;
    window.downloadCurrentMidi = downloadCurrentMidi;

    window.playRecordedTrack = playRecordedTrack;
    window.stopRecordedTrack = stopRecordedTrack;
    window.toggleRecordedTrackLoop = toggleRecordedTrackLoop;
    window.saveRecordedTrack = saveRecordedTrack;
</script>

<style>
    .circular-spectrum-container {
        margin: -50px !important;
        width: calc(100vw + 100px) !important;
        height: calc(100vh + 100px) !important;
    }

    * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
    }

    body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        height: 100vh;
        overflow-x: hidden;
        padding-bottom: 70px;
        /* Space for sticky bar */
    }

    .progression-overlay {
        position: absolute;
        top: 5%;
        left: 50%;
        transform: translateX(-50%);
        color: white;
        font-size: 2.5rem;
        font-weight: bold;
        text-align: center;
        z-index: 10;
        text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.9);
        font-family: "Oswald", monospace;
        padding: 20px;
        border-radius: 15px;
        backdrop-filter: blur(10px);
        max-width: 100vw;
        word-wrap: break-word;
    }

    /* Full-Screen Waveform Centerpiece */
    .waveform-centerpiece {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        z-index: 1;
        background: linear-gradient(135deg, #0a0a0a, #1a1a2e, #16213e);
        display: flex;
        align-items: center;
        justify-content: center;
    }

    /* Override the component's container to be truly full-screen */
    .circular-spectrum-container {
        border-radius: 0 !important;
        border: none !important;
        box-shadow: none !important;
        background: transparent !important;
        overflow: visible !important;
    }

    canvas.spectrum-canvas {
        width: 100vw !important;
        height: 100vh !important;
        min-width: 1000px !important;
        min-height: 600px !important;
    }

    /* Make sure the canvas fills everything */
    .circular-spectrum-container .spectrum-canvas {
        border-radius: 0 !important;
    }

    /* Also remove the section wrapper styles if you still have them */
    .large-waveform-section {
        border-radius: 0 !important;
        border: none !important;
        box-shadow: none !important;
        margin: 0 !important;
        padding: 0 !important;
    }

    .main-visualizer {
        width: 100% !important;
        height: 100vh !important;
        opacity: 1 !important;
        /* Full opacity - make it the star */
    }

    /* Overlay Controls */
    .overlay-controls {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        z-index: 2;
        pointer-events: none;
        /* Allow clicks to pass through */
    }

    .overlay-controls > * {
        pointer-events: auto;
        /* Re-enable clicks on child elements */
    }

    /* Corner Status */
    .corner-status {
        position: absolute;
        top: 20px;
        right: 20px;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 8px 15px;
        border-radius: 20px;
        backdrop-filter: blur(10px);
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 12px;
        border: 1px solid rgba(255, 255, 255, 0.2);
    }

    .status-dot {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: #95a5a6;
        transition: all 0.3s ease;
    }

    .status-dot.connected {
        background: #27ae60;
        box-shadow: 0 0 10px rgba(39, 174, 96, 0.5);
        animation: pulse 2s infinite;
    }

    /* Floating Content */
    .floating-content {
        position: relative;
        z-index: 1;
        min-height: calc(100vh - 70px);
        padding: 20px;
        display: flex;
        flex-direction: column;
        gap: 20px;
        align-items: center;
    }

    /* Content Cards */
    .content-card {
        background: rgba(255, 255, 255, 0.95);
        backdrop-filter: blur(20px);
        border-radius: 20px;
        padding: 30px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
        border: 1px solid rgba(255, 255, 255, 0.2);
        max-width: 600px;
        width: 100%;
        transition: all 0.3s ease;
    }

    .content-card:hover {
        transform: translateY(-5px);
        box-shadow: 0 12px 40px rgba(0, 0, 0, 0.3);
    }

    .content-card h3 {
        color: #2c3e50;
        margin-bottom: 20px;
        text-align: center;
        font-size: 1.5rem;
    }

    .content-card h4 {
        color: #2c3e50;
        margin-bottom: 15px;
        font-size: 1.3rem;
    }

    /* Card-specific styling */
    .record-card {
        background: linear-gradient(
            135deg,
            rgba(52, 152, 219, 0.95),
            rgba(155, 89, 182, 0.95)
        );
        color: white;
    }

    .record-card h3,
    .record-card label {
        color: white;
    }

    .generate-card {
        background: linear-gradient(
            135deg,
            rgba(230, 126, 34, 0.95),
            rgba(231, 76, 60, 0.95)
        );
        color: white;
    }

    .generate-card h3,
    .generate-card label {
        color: white;
    }

    .results-card {
        background: linear-gradient(
            135deg,
            rgba(39, 174, 96, 0.95),
            rgba(46, 204, 113, 0.95)
        );
        color: white;
        max-width: 800px;
    }

    .results-card h3,
    .results-card h4,
    .results-card label {
        color: white;
    }

    /* Form Elements */
    label {
        display: block;
        margin: 15px 0;
        font-weight: 500;
    }

    select,
    input[type="range"] {
        padding: 10px;
        margin: 8px 5px;
        border: 2px solid rgba(255, 255, 255, 0.3);
        border-radius: 10px;
        font-size: 14px;
        background: rgba(255, 255, 255, 0.9);
        color: #2c3e50;
    }

    /* Sticky MIDI Control Bar */
    .midi-control-bar {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        height: 70px;
        background: linear-gradient(
            135deg,
            rgba(44, 62, 80, 0.95),
            rgba(52, 73, 94, 0.95)
        );
        border-top: 2px solid #3498db;
        box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.5);
        z-index: 1000;
        backdrop-filter: blur(20px);
    }

    /* Updated Layout: Left-Center-Right Distribution */
    .midi-bar-content {
        display: flex;
        align-items: center;
        justify-content: space-between;
        height: 100%;
        max-width: 1200px;
        margin: 0 auto;
        padding: 0 20px;
    }

    .left-controls,
    .center-controls,
    .right-controls {
        display: flex;
        align-items: center;
        /* Ensures all items are vertically centered */
        gap: 15px;
    }

    /* Left Controls - Flexible layout for MIDI player above arrangement controls */
    .left-controls {
        position: relative;
        /* Add this */
        justify-content: flex-start;
        flex: 1;
        flex-direction: row;
        /* Change back to row */
        align-items: center;
        /* Change back to center */
        gap: 15px;
        /* Change back to 15px */
    }

    /* Arrangement controls container - horizontal layout */
    .arrangement-controls-wrapper {
        display: flex;
        align-items: center;
        gap: 15px;
    }

    /* Center Controls - Piano */
    .center-controls {
        justify-content: center;
        flex: 1;
    }

    /* Right Controls - Record & Metronome */
    .right-controls {
        justify-content: flex-end;
        flex: 1;
    }

    /* Arrangement Controls */
    .arrangement-controls-container {
        position: relative;
    }

    .arrangement-controls-toggle {
        width: 45px;
        height: 45px;
        border: 2px solid #e74c3c;
        border-radius: 50%;
        background: linear-gradient(135deg, #e74c3c, #c0392b);
        color: white;
        font-size: 18px;
        cursor: pointer;
        transition: all 0.3s ease;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .arrangement-controls-toggle:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 15px rgba(231, 76, 60, 0.4);
    }

    .arrangement-controls-toggle.active {
        background: linear-gradient(135deg, #c0392b, #a93226);
    }

    .arrangement-controls-menu {
        position: absolute;
        bottom: 55px;
        left: 0;
        width: 280px;
        background: white;
        border: 2px solid #e74c3c;
        border-radius: 15px;
        padding: 20px;
        box-shadow: 0 -5px 25px rgba(0, 0, 0, 0.3);
        transform: translateY(20px);
        opacity: 0;
        visibility: hidden;
        transition: all 0.3s ease;
        z-index: 1001;
    }

    .arrangement-controls-menu.show {
        transform: translateY(0);
        opacity: 1;
        visibility: visible;
    }

    /* Generate Arrangement Button */
    .generate-arrangement-btn {
        padding: 12px 20px;
        border: 2px solid #f39c12;
        border-radius: 25px;
        background: linear-gradient(135deg, #f39c12, #e67e22);
        color: white;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s ease;
        font-size: 14px;
        white-space: nowrap;
    }

    .generate-arrangement-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 15px rgba(243, 156, 18, 0.4);
    }

    .generate-arrangement-btn:disabled {
        opacity: 0.6;
        cursor: not-allowed;
        transform: none;
        box-shadow: none;
    }

    /* Piano Controls */
    .piano-controls-container {
        position: relative;
    }

    .piano-controls-toggle {
        width: 45px;
        height: 45px;
        border: 2px solid #9b59b6;
        border-radius: 50%;
        background: linear-gradient(135deg, #9b59b6, #8e44ad);
        color: white;
        font-size: 18px;
        cursor: pointer;
        transition: all 0.3s ease;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .piano-controls-toggle:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 15px rgba(155, 89, 182, 0.4);
    }

    .piano-controls-menu {
        position: absolute;
        bottom: 55px;
        left: 50%;
        transform: translateX(-50%) translateY(20px);
        width: 320px;
        background: white;
        border: 2px solid #9b59b6;
        border-radius: 15px;
        padding: 20px;
        box-shadow: 0 -5px 25px rgba(0, 0, 0, 0.3);
        opacity: 0;
        visibility: hidden;
        transition: all 0.3s ease;
        z-index: 9999 !important;
    }

    .piano-controls-menu.show {
        transform: translateX(-50%) translateY(0);
        opacity: 1;
        visibility: visible;
    }

    /* MIDI Device Section */
    .midi-device-section {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-bottom: 15px;
    }

    .midi-dropdown {
        flex: 1;
        padding: 8px 12px;
        border: 2px solid #3498db;
        border-radius: 20px;
        background: rgba(255, 255, 255, 0.9);
        color: #2c3e50;
        font-size: 13px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.3s ease;
        outline: none;
    }

    .refresh-btn {
        width: 35px;
        height: 35px;
        border: 2px solid #27ae60;
        border-radius: 50%;
        background: linear-gradient(135deg, #27ae60, #2ecc71);
        color: white;
        font-size: 14px;
        cursor: pointer;
        transition: all 0.3s ease;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .refresh-btn:hover {
        transform: scale(1.1);
        box-shadow: 0 2px 8px rgba(39, 174, 96, 0.4);
    }

    /* Sticky MIDI Player - positioned above arrangement controls */
    .sticky-midi-player {
        position: absolute;
        bottom: 100%;
        left: 0;
        margin-bottom: 5px;
        display: flex;
        align-items: center;
        gap: 8px;
        background: rgba(255, 255, 255, 0.9);
        border: 2px solid #27ae60;
        border-radius: 12px;
        padding: 6px 10px;
        max-width: 420px;
        align-self: flex-start;
        /* Align to left */
    }

    .sticky-midi-player midi-player {
        background: transparent;
        border: none;
        padding: 0;
        margin: 0;
        height: 35px;
        width: 220px;
        flex-shrink: 1;
    }

    .sticky-midi-controls {
        display: flex;
        gap: 5px;
    }

    .mini-midi-btn {
        width: 30px;
        height: 30px;
        border: 1px solid #27ae60;
        border-radius: 50%;
        background: linear-gradient(135deg, #27ae60, #2ecc71);
        color: white;
        font-size: 12px;
        cursor: pointer;
        transition: all 0.3s ease;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .mini-midi-btn:hover {
        transform: scale(1.1);
        box-shadow: 0 2px 8px rgba(39, 174, 96, 0.4);
    }

    .recorded-track-player {
        position: absolute;
        bottom: 140%;
        /* Position above the sticky player */
        left: 0;
        margin-bottom: 5px;
        display: flex;
        align-items: center;
        gap: 8px;
        background: rgba(255, 255, 255, 0.9);
        border: 2px solid #3498db;
        /* Different color to distinguish */
        border-radius: 12px;
        padding: 6px 10px;
        max-width: 420px;
        align-self: flex-start;
    }

    .recorded-track-player midi-player {
        background: transparent;
        border: none;
        padding: 0;
        margin: 0;
        height: 35px;
        width: 220px;
        flex-shrink: 1;
    }

    .recorded-track-controls {
        display: flex;
        gap: 5px;
    }

    .control-group {
        margin-bottom: 15px;
        display: flex;
        align-items: center;
        gap: 10px;
    }

    .control-group label {
        min-width: 60px;
        font-weight: 600;
        color: #2c3e50;
        font-size: 13px;
        margin: 0;
    }

    /* Button Styles */
    button {
        padding: 12px 20px;
        margin: 5px;
        border: none;
        border-radius: 10px;
        cursor: pointer;
        font-weight: 600;
        transition: all 0.3s ease;
        font-size: 14px;
    }

    button:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
    }

    .record-btn {
        background: linear-gradient(45deg, #e74c3c, #c0392b);
        color: white;
        width: 45px;
        height: 45px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 18px;
        margin: 0;
        padding: 0;
    }

    .record-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 15px rgba(231, 76, 60, 0.4);
    }

    .stop-btn {
        background: linear-gradient(45deg, #ffffff, #ffffff);
        color: white;
    }

    .analyze-btn {
        background: linear-gradient(45deg, #f39c12, #e67e22);
        color: white;
    }

    .button-group {
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 10px;
        margin: 0;
    }

    /* Status Styles */
    .status {
        padding: 15px;
        margin: 15px 0;
        border-radius: 10px;
        font-weight: 500;
        text-align: center;
        border: 2px solid rgba(255, 255, 255, 0.3);
        background: rgba(255, 255, 255, 0.2);
    }

    .status.ready {
        background: rgba(46, 204, 113, 0.2);
        border-color: rgba(46, 204, 113, 0.5);
    }

    .status.recording {
        background: rgba(255, 193, 7, 0.2);
        border-color: rgba(255, 193, 7, 0.5);
        animation: pulse 2s infinite;
    }

    .status.analyzing {
        background: rgba(52, 152, 219, 0.2);
        border-color: rgba(52, 152, 219, 0.5);
    }

    .status.error {
        background: rgba(231, 76, 60, 0.2);
        border-color: rgba(231, 76, 60, 0.5);
    }

    @keyframes pulse {
        0%,
        100% {
            opacity: 1;
        }

        50% {
            opacity: 0.7;
        }
    }

    /* Right Controls - ensure vertical centering */
    .right-controls {
        justify-content: flex-end;
        flex: 1;
        align-items: center;
        /* This ensures vertical alignment */
    }

    /* Metronome Styles - Horizontal Layout */
    .beat-indicator {
        display: flex;
        flex-direction: row;
        /* Changed to row for horizontal layout */
        align-items: center;
        gap: 10px;
        /* Space between circle and text */
        background: none;
    }

    .beat-circle {
        width: 35px;
        height: 35px;
        border-radius: 50%;
        background: linear-gradient(135deg, #6c757d, #495057);
        transition: all 0.1s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        flex-shrink: 0;
        /* Prevent shrinking */
    }

    .beat-circle.active {
        background: linear-gradient(135deg, #28a745, #20c997);
        transform: scale(1.1);
        box-shadow: 0 6px 20px rgba(40, 167, 69, 0.4);
    }

    .beat-circle.count-in {
        background: linear-gradient(135deg, #ffc107, #fd7e14);
        transform: scale(1.2);
        box-shadow: 0 6px 20px rgba(255, 193, 7, 0.4);
    }

    .beat-count {
        font-size: 14px;
        font-weight: bold;
        color: white;
        min-height: 18px;
        text-align: left;
        /* Changed from center to left */
        white-space: nowrap;
        /* Prevent text wrapping */
        width: 60px;
        /* Fixed width to prevent layout shift */
        flex-shrink: 0;
        /* Prevent shrinking */
    }

    .beat-count.count-in {
        font-size: 18px;
        color: #e67e22;
        animation: pulse-count 0.6s ease-in-out;
    }

    .beat-count.recording {
        color: #28a745;
    }

    @keyframes pulse-count {
        0% {
            transform: scale(1);
        }

        50% {
            transform: scale(1.2);
        }

        100% {
            transform: scale(1);
        }
    }

    /* MIDI Player Styles */
    .midi-player-section {
        margin-top: 30px;
        padding: 25px;
        background: rgba(0, 0, 0, 0.3);
        border-radius: 15px;
        border: 2px solid rgba(255, 255, 255, 0.2);
    }

    midi-player {
        background: rgba(255, 255, 255, 0.9);
        border-radius: 12px;
        padding: 20px;
        display: block;
        margin-bottom: 15px;
    }

    .midi-controls {
        background: rgba(255, 255, 255, 0.8);
        border-radius: 12px;
        padding: 20px;
    }

    /* Responsive adjustments */
    @media (max-width: 1200px) {
        .midi-bar-content {
            gap: 10px;
            padding: 0 15px;
        }

        .left-controls,
        .center-controls,
        .right-controls {
            gap: 10px;
        }

        .sticky-midi-player {
            max-width: 200px;
        }

        .sticky-midi-player midi-player {
            width: 120px;
        }

        .generate-arrangement-btn {
            padding: 10px 15px;
            font-size: 12px;
        }

        .arrangement-controls-menu,
        .piano-controls-menu {
            width: 240px;
        }
    }

    @media (max-width: 768px) {
        .midi-bar-content {
            flex-direction: row;
            justify-content: space-between;
            gap: 5px;
        }

        .left-controls {
            gap: 5px;
        }

        .center-controls,
        .right-controls {
            flex: none;
            gap: 5px;
        }

        .sticky-midi-player {
            max-width: 200px;
            padding: 4px 6px;
        }

        .sticky-midi-player midi-player {
            width: 120px;
            height: 30px;
        }

        .generate-arrangement-btn {
            font-size: 11px;
            padding: 8px 12px;
        }

        .arrangement-controls-menu,
        .piano-controls-menu {
            width: 200px;
        }

        .beat-circle {
            width: 30px;
            height: 30px;
        }

        .beat-count {
            font-size: 12px;
            width: 50px;
            /* Smaller fixed width on mobile */
        }

        .beat-indicator {
            gap: 8px;
            /* Smaller gap on mobile */
        }
    }

    /* Responsive Design */
    @media (max-width: 768px) {
        .floating-content {
            padding: 10px;
        }

        .content-card {
            padding: 20px;
            margin: 0 10px;
        }
    }
</style>
