---
// src/pages/visualization-options.astro
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audio Visualization Options</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #111;
            color: white;
            font-family: Arial, sans-serif;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        .visualization-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        
        .viz-option {
            border: 1px solid #333;
            border-radius: 12px;
            padding: 15px;
            background: #1a1a1a;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .viz-option:hover {
            border-color: #555;
            background: #222;
            transform: translateY(-2px);
        }
        
        .viz-option.active {
            border-color: #4ecdc4;
            background: #1a2a2a;
        }
        
        .viz-canvas {
            width: 100%;
            height: 200px;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a0a1a 100%);
            border-radius: 8px;
            margin: 10px 0;
            position: relative;
            overflow: hidden;
        }
        
        .viz-title {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 8px;
            color: #4ecdc4;
        }
        
        .viz-description {
            font-size: 14px;
            color: #aaa;
            margin-bottom: 10px;
        }
        
        .main-visualization {
            width: 100%;
            height: 500px;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a0a1a 100%);
            border-radius: 12px;
            margin: 20px 0;
            position: relative;
            border: 2px solid #333;
        }
        
        .controls {
            text-align: center;
            margin: 20px 0;
        }
        
        .btn {
            background: #333;
            color: white;
            border: 1px solid #555;
            padding: 12px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin: 0 10px;
            transition: background 0.3s;
        }
        
        .btn:hover {
            background: #444;
        }
        
        .status {
            text-align: center;
            font-size: 14px;
            color: #888;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üéµ Audio Visualization Options</h1>
        <p>Choose your preferred visualization style:</p>
        
        <!-- Visualization Options Grid -->
        <div class="visualization-grid">
            <!-- Option 1: Traditional Waveform -->
            <div class="viz-option" data-type="waveform">
                <div class="viz-title">üåä Traditional Waveform</div>
                <div class="viz-description">Classic oscilloscope-style waveform display</div>
                <canvas class="viz-canvas" id="preview-waveform"></canvas>
            </div>
            
            <!-- Option 2: Frequency Bars -->
            <div class="viz-option" data-type="bars">
                <div class="viz-title">üìä Frequency Bars</div>
                <div class="viz-description">Equalizer-style vertical bars for each frequency</div>
                <canvas class="viz-canvas" id="preview-bars"></canvas>
            </div>
            
            <!-- Option 3: Circular Spectrum -->
            <div class="viz-option" data-type="circular">
                <div class="viz-title">‚≠ï Circular Spectrum</div>
                <div class="viz-description">Radial frequency display with pulsing center</div>
                <canvas class="viz-canvas" id="preview-circular"></canvas>
            </div>
            
            <!-- Option 4: Particle Cloud -->
            <div class="viz-option" data-type="particles">
                <div class="viz-title">‚ú® Particle Cloud</div>
                <div class="viz-description">Your current PS2-style particle system</div>
                <canvas class="viz-canvas" id="preview-particles"></canvas>
            </div>
            
            <!-- Option 5: Mesh Waves -->
            <div class="viz-option" data-type="mesh">
                <div class="viz-title">üåê Mesh Waves</div>
                <div class="viz-description">3D plane with audio-driven height displacement</div>
                <canvas class="viz-canvas" id="preview-mesh"></canvas>
            </div>
            
            <!-- Option 6: Spiral Galaxy -->
            <div class="viz-option" data-type="spiral">
                <div class="viz-title">üåå Spiral Galaxy</div>
                <div class="viz-description">Rotating spiral arms with frequency-based colors</div>
                <canvas class="viz-canvas" id="preview-spiral"></canvas>
            </div>
        </div>
        
        <!-- Main Visualization Area -->
        <div class="main-visualization" id="mainVisualization">
            <canvas id="mainCanvas" style="width: 100%; height: 100%;"></canvas>
            <div class="status" id="statusText">Select a visualization style above</div>
        </div>
        
        <!-- Controls -->
        <div class="controls">
            <button class="btn" id="testToneBtn">üîä Play Test Tone</button>
            <button class="btn" id="microphoneBtn">üé§ Use Microphone</button>
            <button class="btn" id="stopAudioBtn">‚èπÔ∏è Stop Audio</button>
        </div>
        
        <div class="status" id="audioStatus">Audio: Inactive</div>
    </div>

    <script>
        class VisualizationSelector {
            constructor() {
                this.mainCanvas = document.getElementById('mainCanvas');
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.currentVisualization = null;
                this.animationId = null;
                
                // Audio components
                this.audioContext = null;
                this.analyser = null;
                this.dataArray = null;
                this.isAudioActive = false;
                
                this.init();
            }
            
            async init() {
                await this.loadThreeJS();
                this.setupThreeJS();
                this.createPreviews();
                this.startMainAnimation();
            }
            
            async loadThreeJS() {
                if (window.THREE) return;
                
                return new Promise((resolve, reject) => {
                    const script = document.createElement('script');
                    script.src = 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js';
                    script.onload = () => resolve();
                    script.onerror = () => reject(new Error('Failed to load Three.js'));
                    document.head.appendChild(script);
                });
            }
            
            setupThreeJS() {
                // Main scene setup
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x0a0a1a);
                
                const width = this.mainCanvas.clientWidth;
                const height = this.mainCanvas.clientHeight;
                
                this.camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
                this.camera.position.z = 50;
                
                this.renderer = new THREE.WebGLRenderer({ 
                    canvas: this.mainCanvas,
                    antialias: true 
                });
                this.renderer.setSize(width, height);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            }
            
            createPreviews() {
                // Create static previews for each visualization type
                this.createWaveformPreview();
                this.createBarsPreview();
                this.createCircularPreview();
                this.createParticlesPreview();
                this.createMeshPreview();
                this.createSpiralPreview();
            }
            
            createWaveformPreview() {
                const canvas = document.getElementById('preview-waveform');
                const ctx = canvas.getContext('2d');
                canvas.width = canvas.clientWidth;
                canvas.height = canvas.clientHeight;
                
                ctx.fillStyle = '#0a0a1a';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw sample waveform
                ctx.strokeStyle = '#4ecdc4';
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                for (let x = 0; x < canvas.width; x++) {
                    const y = canvas.height / 2 + Math.sin(x * 0.02) * 50 * Math.sin(x * 0.001);
                    if (x === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
            }
            
            createBarsPreview() {
                const canvas = document.getElementById('preview-bars');
                const ctx = canvas.getContext('2d');
                canvas.width = canvas.clientWidth;
                canvas.height = canvas.clientHeight;
                
                ctx.fillStyle = '#0a0a1a';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw sample frequency bars
                const barCount = 32;
                const barWidth = canvas.width / barCount;
                
                for (let i = 0; i < barCount; i++) {
                    const height = Math.random() * canvas.height * 0.8;
                    const hue = (i / barCount) * 120 + 180; // Blue to teal
                    ctx.fillStyle = `hsl(${hue}, 60%, 50%)`;
                    ctx.fillRect(i * barWidth, canvas.height - height, barWidth - 1, height);
                }
            }
            
            createCircularPreview() {
                const canvas = document.getElementById('preview-circular');
                const ctx = canvas.getContext('2d');
                canvas.width = canvas.clientWidth;
                canvas.height = canvas.clientHeight;
                
                ctx.fillStyle = '#0a0a1a';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const radius = Math.min(centerX, centerY) * 0.8;
                
                // Draw sample circular spectrum
                const barCount = 64;
                for (let i = 0; i < barCount; i++) {
                    const angle = (i / barCount) * Math.PI * 2;
                    const barHeight = Math.random() * 40 + 10;
                    
                    const x1 = centerX + Math.cos(angle) * radius;
                    const y1 = centerY + Math.sin(angle) * radius;
                    const x2 = centerX + Math.cos(angle) * (radius + barHeight);
                    const y2 = centerY + Math.sin(angle) * (radius + barHeight);
                    
                    const hue = (i / barCount) * 360;
                    ctx.strokeStyle = `hsl(${hue}, 60%, 50%)`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.stroke();
                }
            }
            
            createParticlesPreview() {
                const canvas = document.getElementById('preview-particles');
                const ctx = canvas.getContext('2d');
                canvas.width = canvas.clientWidth;
                canvas.height = canvas.clientHeight;
                
                ctx.fillStyle = '#0a0a1a';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw sample particles
                for (let i = 0; i < 100; i++) {
                    const x = Math.random() * canvas.width;
                    const y = Math.random() * canvas.height;
                    const size = Math.random() * 3 + 1;
                    
                    ctx.fillStyle = `hsl(${200 + Math.random() * 60}, 60%, 50%)`;
                    ctx.fillRect(x, y, size, size);
                }
            }
            
            createMeshPreview() {
                const canvas = document.getElementById('preview-mesh');
                const ctx = canvas.getContext('2d');
                canvas.width = canvas.clientWidth;
                canvas.height = canvas.clientHeight;
                
                ctx.fillStyle = '#0a0a1a';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw sample mesh grid
                ctx.strokeStyle = '#4ecdc4';
                ctx.lineWidth = 1;
                
                const gridSize = 20;
                for (let x = 0; x <= canvas.width; x += gridSize) {
                    for (let y = 0; y <= canvas.height; y += gridSize) {
                        const offset = Math.sin(x * 0.01 + y * 0.01) * 5;
                        ctx.strokeRect(x, y + offset, gridSize, gridSize);
                    }
                }
            }
            
            createSpiralPreview() {
                const canvas = document.getElementById('preview-spiral');
                const ctx = canvas.getContext('2d');
                canvas.width = canvas.clientWidth;
                canvas.height = canvas.clientHeight;
                
                ctx.fillStyle = '#0a0a1a';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                
                // Draw sample spiral
                ctx.strokeStyle = '#4ecdc4';
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                for (let angle = 0; angle < Math.PI * 8; angle += 0.1) {
                    const radius = angle * 3;
                    const x = centerX + Math.cos(angle) * radius;
                    const y = centerY + Math.sin(angle) * radius;
                    
                    if (angle === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
            }
            
            selectVisualization(type) {
                // Clear previous visualization
                if (this.currentVisualization) {
                    this.scene.clear();
                }
                
                // Update UI
                document.querySelectorAll('.viz-option').forEach(el => el.classList.remove('active'));
                document.querySelector(`[data-type="${type}"]`).classList.add('active');
                document.getElementById('statusText').textContent = `${type.charAt(0).toUpperCase() + type.slice(1)} visualization active`;
                
                // Create new visualization
                switch(type) {
                    case 'waveform':
                        this.createWaveformVisualization();
                        break;
                    case 'bars':
                        this.createBarsVisualization();
                        break;
                    case 'circular':
                        this.createCircularVisualization();
                        break;
                    case 'particles':
                        this.createParticlesVisualization();
                        break;
                    case 'mesh':
                        this.createMeshVisualization();
                        break;
                    case 'spiral':
                        this.createSpiralVisualization();
                        break;
                }
                
                this.currentVisualization = type;
            }
            
            createWaveformVisualization() {
                // Create line geometry for waveform
                const points = [];
                for (let i = 0; i < 512; i++) {
                    points.push(new THREE.Vector3((i - 256) * 0.1, 0, 0));
                }
                
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({ color: 0x4ecdc4 });
                this.waveformLine = new THREE.Line(geometry, material);
                this.scene.add(this.waveformLine);
            }
            
            createBarsVisualization() {
                // Create frequency bars
                this.frequencyBars = [];
                const barCount = 64;
                
                for (let i = 0; i < barCount; i++) {
                    const geometry = new THREE.BoxGeometry(0.8, 1, 0.8);
                    const hue = (i / barCount) * 0.3 + 0.5; // Blue to teal
                    const material = new THREE.MeshBasicMaterial({ color: new THREE.Color().setHSL(hue, 0.6, 0.5) });
                    const bar = new THREE.Mesh(geometry, material);
                    
                    bar.position.x = (i - barCount / 2) * 1.2;
                    bar.position.y = 0;
                    
                    this.scene.add(bar);
                    this.frequencyBars.push(bar);
                }
            }
            
            createCircularVisualization() {
                // Create circular spectrum
                this.circularBars = [];
                const barCount = 128;
                
                for (let i = 0; i < barCount; i++) {
                    const geometry = new THREE.BoxGeometry(0.2, 1, 0.2);
                    const hue = (i / barCount);
                    const material = new THREE.MeshBasicMaterial({ color: new THREE.Color().setHSL(hue, 0.6, 0.5) });
                    const bar = new THREE.Mesh(geometry, material);
                    
                    const angle = (i / barCount) * Math.PI * 2;
                    const radius = 20;
                    bar.position.x = Math.cos(angle) * radius;
                    bar.position.z = Math.sin(angle) * radius;
                    bar.rotation.y = angle;
                    
                    this.scene.add(bar);
                    this.circularBars.push(bar);
                }
            }
            
            createParticlesVisualization() {
                // Your existing particle system
                const particleCount = 3000;
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                const colors = new Float32Array(particleCount * 3);
                
                for (let i = 0; i < particleCount; i++) {
                    const i3 = i * 3;
                    positions[i3] = (Math.random() - 0.5) * 100;
                    positions[i3 + 1] = (Math.random() - 0.5) * 60;
                    positions[i3 + 2] = (Math.random() - 0.5) * 60;
                    
                    colors[i3] = 0.1 + Math.random() * 0.3;
                    colors[i3 + 1] = 0.3 + Math.random() * 0.5;
                    colors[i3 + 2] = 0.7 + Math.random() * 0.3;
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                
                const material = new THREE.PointsMaterial({
                    size: 3,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.8,
                    blending: THREE.AdditiveBlending
                });
                
                this.particles = new THREE.Points(geometry, material);
                this.scene.add(this.particles);
            }
            
            createMeshVisualization() {
                // Create wave mesh
                const geometry = new THREE.PlaneGeometry(60, 60, 64, 64);
                const material = new THREE.MeshBasicMaterial({ 
                    color: 0x4ecdc4, 
                    wireframe: true,
                    transparent: true,
                    opacity: 0.8
                });
                
                this.waveMesh = new THREE.Mesh(geometry, material);
                this.waveMesh.rotation.x = -Math.PI / 3;
                this.scene.add(this.waveMesh);
            }
            
            createSpiralVisualization() {
                // Create spiral galaxy
                this.spiralPoints = [];
                const spiralCount = 3;
                
                for (let s = 0; s < spiralCount; s++) {
                    const points = [];
                    for (let i = 0; i < 200; i++) {
                        const angle = (i / 200) * Math.PI * 6 + (s * Math.PI * 2 / spiralCount);
                        const radius = i * 0.3;
                        points.push(new THREE.Vector3(
                            Math.cos(angle) * radius,
                            Math.sin(angle) * radius,
                            (Math.random() - 0.5) * 10
                        ));
                    }
                    
                    const geometry = new THREE.BufferGeometry().setFromPoints(points);
                    const material = new THREE.LineBasicMaterial({ 
                        color: new THREE.Color().setHSL(s / spiralCount, 0.6, 0.5)
                    });
                    const spiral = new THREE.Line(geometry, material);
                    this.scene.add(spiral);
                    this.spiralPoints.push(spiral);
                }
            }
            
            async initAudio(source) {
                if (!this.audioContext) {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                
                if (this.audioContext.state === 'suspended') {
                    await this.audioContext.resume();
                }
                
                this.analyser = this.audioContext.createAnalyser();
                this.analyser.fftSize = 512;
                this.analyser.smoothingTimeConstant = 0.8;
                
                let audioSource;
                
                if (source === 'microphone') {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    audioSource = this.audioContext.createMediaStreamSource(stream);
                } else if (source === 'tone') {
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(440, this.audioContext.currentTime);
                    gainNode.gain.setValueAtTime(0.1, this.audioContext.currentTime);
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.analyser);
                    this.analyser.connect(this.audioContext.destination);
                    
                    oscillator.start();
                    audioSource = oscillator;
                }
                
                if (audioSource && source !== 'tone') {
                    audioSource.connect(this.analyser);
                    this.analyser.connect(this.audioContext.destination);
                }
                
                this.dataArray = new Uint8Array(this.analyser.frequencyBinCount);
                this.isAudioActive = true;
                document.getElementById('audioStatus').textContent = 'Audio: Active';
            }
            
            startMainAnimation() {
                const animate = () => {
                    this.animationId = requestAnimationFrame(animate);
                    
                    if (this.isAudioActive && this.analyser && this.dataArray) {
                        this.analyser.getByteFrequencyData(this.dataArray);
                        this.updateVisualization();
                    }
                    
                    this.renderer.render(this.scene, this.camera);
                };
                
                animate();
            }
            
            updateVisualization() {
                if (!this.currentVisualization) return;
                
                switch(this.currentVisualization) {
                    case 'waveform':
                        this.updateWaveform();
                        break;
                    case 'bars':
                        this.updateBars();
                        break;
                    case 'circular':
                        this.updateCircular();
                        break;
                    case 'particles':
                        this.updateParticles();
                        break;
                    case 'mesh':
                        this.updateMesh();
                        break;
                    case 'spiral':
                        this.updateSpiral();
                        break;
                }
            }
            
            updateWaveform() {
                if (!this.waveformLine) return;
                
                const positions = this.waveformLine.geometry.attributes.position.array;
                for (let i = 0; i < 512; i++) {
                    positions[i * 3 + 1] = (this.dataArray[i] / 255 - 0.5) * 20;
                }
                this.waveformLine.geometry.attributes.position.needsUpdate = true;
            }
            
            updateBars() {
                if (!this.frequencyBars) return;
                
                this.frequencyBars.forEach((bar, i) => {
                    const value = this.dataArray[i * 4] / 255;
                    bar.scale.y = Math.max(0.1, value * 10);
                    bar.position.y = bar.scale.y / 2;
                });
            }
            
            updateCircular() {
                if (!this.circularBars) return;
                
                this.circularBars.forEach((bar, i) => {
                    const value = this.dataArray[i * 2] / 255;
                    bar.scale.y = Math.max(0.1, value * 15);
                });
            }
            
            updateParticles() {
                if (!this.particles) return;
                
                const positions = this.particles.geometry.attributes.position.array;
                const time = Date.now() * 0.001;
                
                for (let i = 0; i < positions.length / 3; i++) {
                    const i3 = i * 3;
                    const frequency = this.dataArray[i % this.dataArray.length] / 255;
                    
                    positions[i3 + 1] += Math.sin(time + i * 0.1) * frequency * 20;
                }
                
                this.particles.geometry.attributes.position.needsUpdate = true;
                this.particles.rotation.y += 0.005;
            }
            
            updateMesh() {
                if (!this.waveMesh) return;
                
                const positions = this.waveMesh.geometry.attributes.position.array;
                const time = Date.now() * 0.001;
                
                for (let i = 0; i < positions.length / 3; i++) {
                    const i3 = i * 3;
                    const frequency = this.dataArray[i % this.dataArray.length] / 255;
                    positions[i3 + 2] = Math.sin(time + i * 0.01) * frequency * 10;
                }
                
                this.waveMesh.geometry.attributes.position.needsUpdate = true;
            }
            
            updateSpiral() {
                if (!this.spiralPoints) return;
                
                this.spiralPoints.forEach((spiral, index) => {
                    spiral.rotation.z += 0.01 + (this.dataArray[index * 10] / 255) * 0.05;
                });
            }
            
            stopAudio() {
                if (this.audioContext) {
                    this.audioContext.close();
                    this.audioContext = null;
                }
                this.isAudioActive = false;
                document.getElementById('audioStatus').textContent = 'Audio: Inactive';
            }
        }
        
        // Global instance
        let visualizer;
        
        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', () => {
            visualizer = new VisualizationSelector();
            
            // Set up visualization option click handlers
            document.querySelectorAll('.viz-option').forEach(option => {
                option.addEventListener('click', () => {
                    const type = option.dataset.type;
                    visualizer.selectVisualization(type);
                });
            });
            
            // Set up control button handlers
            document.getElementById('testToneBtn').addEventListener('click', async () => {
                try {
                    await visualizer.initAudio('tone');
                } catch (error) {
                    console.error('Test tone failed:', error);
                }
            });
            
            document.getElementById('microphoneBtn').addEventListener('click', async () => {
                try {
                    await visualizer.initAudio('microphone');
                } catch (error) {
                    console.error('Microphone failed:', error);
                    alert('Microphone access failed: ' + error.message);
                }
            });
            
            document.getElementById('stopAudioBtn').addEventListener('click', () => {
                visualizer.stopAudio();
            });
        });
        
        // Handle window resize
        window.addEventListener('resize', () => {
            if (visualizer && visualizer.camera && visualizer.renderer) {
                const canvas = visualizer.mainCanvas;
                const width = canvas.clientWidth;
                const height = canvas.clientHeight;
                
                visualizer.camera.aspect = width / height;
                visualizer.camera.updateProjectionMatrix();
                visualizer.renderer.setSize(width, height);
            }
        });
    </script>
</body>
</html>